<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>

<link rel="manifest" href="manifest.webmanifest">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="„Ç¶„ÇØ„É¨„É¨">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="#88cfd3" name="theme-color"/>
<title>„Ç¶„ÇØ„É¨„É¨„Éª„Ç≤„Éº„É†</title>
<style>/* iphone-viewport-fix */

    :root{
      --vh: 1vh;

      --primary: #ff7a3d;
      --card: rgba(255,255,255,0.92);
      --shadow: rgba(0,0,0,0.18);
    }
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
      -webkit-text-size-adjust: 100%;
      background: linear-gradient(to bottom, #7ab1cc 0%, #a8e6cf 100%);
      color: #4a3728;
      font-family: system-ui, -apple-system, sans-serif;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
    #app { position: fixed; inset: 0; width: 100%; height: 100dvh; height: calc(var(--vh) * 100); overflow: hidden; padding-top: env(safe-area-inset-top); padding-left: env(safe-area-inset-left); padding-right: env(safe-area-inset-right); padding-bottom: env(safe-area-inset-bottom); box-sizing: border-box; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }

    /* „É°„Éã„É•„Éº„Ç™„Éº„Éê„Éº„É¨„Ç§ */
    #menu-overlay {
      touch-action: pan-y;
      position: fixed; inset: 0; background: rgba(0,0,0,0.32);
      display: flex; align-items: flex-start; justify-content: center;
      z-index: 100; backdrop-filter: blur(2px);
      box-sizing: border-box;
      padding: calc(env(safe-area-inset-top) + 8px) 8px calc(env(safe-area-inset-bottom) + 8px);
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .menu-card {
      position: relative;
      background: var(--card); width: min(560px, 96vw);
      max-height: calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 16px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
      border-radius: 26px; padding: 16px;
      padding-bottom: calc(16px + env(safe-area-inset-bottom));
      box-shadow: 0 10px 0 rgba(122,177,204,0.28), 0 16px 32px var(--shadow);
      display: flex; flex-direction: column; gap: 10px;
    }
    .menu-card h1 { margin: 0 0 6px; font-size: 22px; text-align: center; }
    
    /* ‚òÖUIÊîπÂñÑ: „Ç∞„É™„ÉÉ„Éâ„É¨„Ç§„Ç¢„Ç¶„Éà„Åß„Éú„Çø„É≥„Çµ„Ç§„Ç∫„ÇíÁµ±‰∏Ä */
    .menu-main {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .menu-btn {
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(255,255,255,0.90)); color: #4a3728;
      border: none; border-radius: 22px; padding: 12px 14px;
      cursor: pointer; display: flex; gap: 12px; align-items: center;
      box-shadow: 0 6px 0 rgba(122,177,204,0.26);
      transition: transform 0.08s; text-align: left;
      width: 100%; /* Grid„ÅÑ„Å£„Å±„ÅÑ„Å´Â∫É„Åí„Çã */
      box-sizing: border-box;
      min-height: 80px; /* È´ò„ÅïÊèÉ„Åà */
    }
    .menu-btn:active { transform: translateY(2px); box-shadow: none; }
    .badge { flex: 0 0 38px; height: 38px; border-radius: 12px; background: var(--primary); display: flex; align-items: center; justify-content: center; font-size: 20px; color: #fff; }
    .menu-btn.mode2 .badge{ background: #ffde59; color:#4a3728; }
    .menu-btn.mode3 .badge{ background: #7ed957; }
    .menu-btn.mode4 .badge{ background: #5ce1e6; color: #133; }
    
    .menu-text { display:flex; flex-direction:column; flex: 1; min-width:0; }
    .menu-text .title { font-size: 16px; font-weight: 900; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .menu-text small { font-size: 11px; opacity: 0.8; line-height: 1.2; }

    /* „Åç„Çâ„Åç„Çâ„Åº„ÅóÔºö2√ó2„Ç∞„É™„ÉÉ„Éâ„ÅÆ‰∏ÄÊû†„Å®„Åó„Å¶ÈÖçÁΩÆ */
    .song-block{ display:flex; flex-direction:column; gap:6px; grid-column:auto; }

/* „É¢„Éº„ÉâÈÅ∏Êäû */
    .mode-select { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(0,0,0,0.1); }
    
    /* „É¢„Éº„Éâ/Èü≥„ÅÆË®≠ÂÆöË°åÔºà„Ç≥„É≥„Éë„ÇØ„Éà2„Ç´„É©„É†Ôºâ */
    .settings-row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px; align-items:stretch; }
    .settings-box{
      background: rgba(255,255,255,0.72);
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 18px;
      padding: 10px 12px;
      box-shadow: 0 8px 18px rgba(0,0,0,0.07);
    }
    /* Êó¢Â≠ò„ÅÆ„Çµ„Ç¶„É≥„ÉâÂàáÊõøÊû†„ÅÆ‰∏äÈÉ®„Éú„Éº„ÉÄ„Éº/‰ΩôÁôΩ„ÅØÁÆ±ÂÜÖ„Åß„ÅØ‰∏çË¶Å */
    .settings-box .sound-select-wrap{ margin-top:0; padding-top:0; border-top:0; }
    /* „Çø„ÉÉ„Éó„É¢„Éº„Éâ„ÅØÈü≥ÂàáÊõø„ÇíÈùûË°®Á§∫ ‚Üí Âè≥ÂÅ¥„Å†„Åë„Å´ */
    body.is-tap .settings-row{ grid-template-columns: 1fr; }
    body.is-tap #sound-box{ display:none; }
    body.is-tap #mode-box{ grid-column:1 / -1; }

    @media (max-height: 420px){
      .settings-box{ padding: 8px 10px; border-radius: 16px; }
      .settings-row{ gap:8px; margin-top:8px; }
    }
.mode-pills { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
    .mode-pill {
      background: rgba(255,255,255,0.78);
      border: 2px solid rgba(255,255,255,0.92);
      border-radius: 999px;
      box-shadow: 0 10px 18px rgba(0,0,0,0.10);
      padding: 7px 14px;
      font-weight: 1000;
      font-size: 11px;
      cursor: pointer;
      user-select: none;
      color: #555;
    }
    .mode-pill.active {
      border-color: rgba(255,122,61,0.95);
      box-shadow: 0 10px 18px rgba(0,0,0,0.10), inset 0 0 0 2px rgba(255,122,61,0.12);
      color: rgba(255,122,61,1);
      background: rgba(255,255,255,0.92);
    }
    .mode-desc{
      margin-top: 6px;
      text-align: center;
      font-weight: 900;
      font-size: 11px;
      opacity: 0.78;
    }

    /* ‚òÖUIÊîπÂñÑ: Èü≥Ê∫êÂàá„ÇäÊõø„Åà„Éú„Çø„É≥ */
    .sound-select-wrap {
      margin-top: 12px; display: flex; flex-direction: column; align-items: center; gap: 4px;
      padding-top: 8px; border-top: 1px dashed rgba(0,0,0,0.1);
    }
    .sound-label { font-size: 11px; font-weight: 900; opacity: 0.85; margin-bottom: 2px; }

    .song-title{ white-space: nowrap; }

    /* menu back button (secondary) - match index pill feel */
    .menu-card .action-btn.btn-secondary{
      background: rgba(255,255,255,0.78);
      border: 2px solid rgba(255,255,255,0.92);
      box-shadow: 0 10px 20px rgba(0,0,0,0.10);
      color: rgba(20,20,20,0.78);
    }


    /* === iPhoneÊ®™: „É°„Éã„É•„Éº„Çí1ÁîªÈù¢„Å´Âèé„ÇÅ„ÇãÔºà„Çπ„ÇØ„É≠„Éº„É´‰∏çË¶ÅÔºâ === */
    @media (orientation: landscape) and (max-height: 430px){
      .menu-card{
        width: min(720px, 98vw);
        max-height: calc(100dvh - 10px);
        padding: 10px;
        gap: 6px;
        overflow-y: auto; -webkit-overflow-scrolling: touch; /* fit + safe scroll */
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
      }
      .menu-card h1{ font-size: 16px; margin: 0 0 4px; }
      .menu-btn{ padding: 8px; border-radius: 14px; gap: 10px; min-height: 60px; }
      .badge{ flex: 0 0 30px; height: 30px; border-radius: 10px; font-size: 16px; }
      .menu-text .title{ font-size: 14px; margin-bottom: 1px; }
      .menu-text small{ font-size: 10px; }

      /* ‰∏äÊÆµ: „É°„Éã„É•„ÉºÈ†ÖÁõÆ„Çí2Âàó„ÅßË©∞„ÇÅ„Çã */
      .menu-main{ gap: 6px; }
      .menu-main .menu-btn{ width: 100%; }

      /* ‰∏ãÊÆµ: „É¢„Éº„Éâ/„ÅØ„ÇÑ„Åï„ÇíÂúßÁ∏Æ„Åó„Å¶ÂøÖ„ÅöË¶ã„Åà„Çã */
      .mode-select{ margin-top: 6px; padding-top: 6px; }
      .mode-pill{ padding: 5px 10px; font-size: 10px; }

      /* Êõ≤„Çπ„Éî„Éº„Éâ„ÅØ„ÄåÊõ≤Ôºö„Åç„Çâ„Åç„ÇâÊòü„ÄçÂÜÖ„Å´Ë°®Á§∫Ôºà„Ç≥„É≥„Éë„ÇØ„ÉàÔºâ */
      #song-speed-wrap.song-speed-inline{margin-top:4px !important; gap:4px !important;}
      #song-speed-wrap.song-speed-inline > div:first-child{font-size:10px !important;}
      #song-speed-wrap.song-speed-inline #song-speed-note{display:none;}
      #song-speed-wrap.song-speed-inline .mode-pill{padding:4px 8px !important; font-size:10px !important;}
    }

    /* „Ç≤„Éº„É†UI */
    #score-panel, #timer-panel {
      position: fixed; z-index: 90; background: rgba(255,255,255,0.85);
      padding: 6px 12px; border-radius: 14px; font-weight: 900; font-size: 18px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1); display: none;
    }
    #score-panel { top: calc(60px + var(--ui-top, 0px) + env(safe-area-inset-top)); right: calc(12px + var(--ui-right, 0px) + env(safe-area-inset-right)); }
    #timer-panel { top: calc(12px + env(safe-area-inset-top)); right: calc(12px + env(safe-area-inset-right)); font-size: 16px; }

    /* Time Bonus Popup Animation */
    @keyframes popUpFade {
      0% { transform: translateY(0) scale(0.8); opacity: 0; }
      20% { transform: translateY(-10px) scale(1.2); opacity: 1; }
      100% { transform: translateY(-40px) scale(1.0); opacity: 0; }
    }
    .time-bonus {
      position: fixed;
      top: calc(40px + env(safe-area-inset-top));
      right: calc(80px + env(safe-area-inset-right));
      color: #ff3d3d;
      font-weight: 1000;
      font-size: 24px;
      text-shadow: 0 2px 0 #fff, 0 0 10px rgba(255,255,255,0.8);
      pointer-events: none;
      z-index: 95;
      animation: popUpFade 1.2s ease-out forwards;
    }

    /* Screen Edge Rainbow Flash (Fever) */
    #screenRainbow {
      position: fixed; inset: 0; z-index: 80; pointer-events: none;
      box-shadow: inset 0 0 0 0px rgba(255,255,0,0);
      transition: box-shadow 0.1s;
    }
    #screenRainbow.active {
      animation: rainbowFlash 0.6s ease-out;
    }
    @keyframes rainbowFlash {
      0% { box-shadow: inset 0 0 60px 20px rgba(255,0,0,0.6); }
      20% { box-shadow: inset 0 0 60px 20px rgba(255,255,0,0.6); }
      40% { box-shadow: inset 0 0 60px 20px rgba(0,255,0,0.6); }
      60% { box-shadow: inset 0 0 60px 20px rgba(0,255,255,0.6); }
      80% { box-shadow: inset 0 0 60px 20px rgba(0,0,255,0.6); }
      100% { box-shadow: inset 0 0 0 0 rgba(0,0,0,0); }
    }

    #stopBtn {
      position: fixed; right: calc(14px + env(safe-area-inset-right)); bottom: calc(14px + env(safe-area-inset-bottom)); z-index: 180; display: none;
      border: none; border-radius: 16px; padding: 12px 18px;
      background: rgba(255,255,255,0.92); font-weight: 900; font-size: 16px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.15); cursor: pointer;
    }
    
    #back-btn {
      position: fixed; top: 12px; left: 12px; z-index: 180;
    }
    #back-btn button {
      border: none; background: rgba(255,255,255,0.6); color: #0d2b3b;
      font-weight: 800; font-size: 12px; padding: 8px 12px; border-radius: 10px; cursor: pointer;
    }

    #chordHud {
      position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
      z-index: 85; display: none; pointer-events: none;
      background: rgba(255,255,255,0.86); border-radius: 18px; padding: 6px 16px;
      font-weight: 900; font-size: 32px; box-shadow: 0 8px 20px rgba(0,0,0,0.1);
    }
    #lyrics-area {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 90%;
      text-align: center; font-size: 28px; font-weight: 900; color: #4a3728;
      text-shadow: 0 2px 8px rgba(255,255,255,0.8); pointer-events: none; z-index:9999;
    }

    /* „Ç™„Éº„Éê„Éº„É¨„Ç§ÂÖ±ÈÄö */
    .overlay-card {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      z-index: 120; background: rgba(0,0,0,0.4); backdrop-filter: blur(4px);
    }
    .card-content {
      background: #fff; width: min(480px, 90vw); border-radius: 20px; padding: 24px;
      text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.3); position: relative;
    }
    .result-score { font-size: 32px; font-weight: 900; margin: 10px 0; color: var(--primary); }
    .action-btn {
      width: 100%; border: none; border-radius: 14px; padding: 14px; font-size: 16px; font-weight: 900;
      cursor: pointer; margin-top: 10px;
    }
    .btn-primary { background: var(--primary); color: #fff; }
    .btn-secondary { background: #eee; color: #555; }

    @media (orientation: landscape) and (max-height: 460px) {
      .menu-list { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .menu-btn { padding: 8px; }
    }
  
    /* FX message (HIT / MISS / SPEED) - comic style (center / bigger) */
#fxMsg{
  position: fixed;
  left: 0px; top: 0px;
  transform: translate(-50%,-50%);
  z-index: 9999;
  display: none;
  pointer-events: none;
  padding: 8px 14px 9px;
  border-radius: 14px;
  background: rgba(0,0,0,0.45);
  color: #fff;
  font-size: 18px;
  font-weight: 900;
  letter-spacing: 0.4px;
  max-width: 92vw;
  text-align: center;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
  backdrop-filter: blur(4px);
}

#fxMsg.speed{
  color: #0b5cff;
  border-color: #0b5cff;
}

#fxMsg.show{
  display:block;
  opacity:1;
  transform: translate(-50%, -50%) scale(1.02);
}

/* BIG COMBO (neck center) */
#comboBig{
  position: fixed;
  left: 50%;
  top: calc(50% + 66px);
  transform: translate(-50%, -50%) rotate(-2deg);
  z-index: 94;
  display: none;
  pointer-events: none;
  font-weight: 1000;
  font-size: 54px;
  color: rgba(255,255,255,0.92);
  text-shadow:
    0 4px 0 #111,
    2px 2px 0 #111,
    -2px 2px 0 #111,
    2px -2px 0 #111,
    -2px -2px 0 #111,
    0 14px 26px rgba(0,0,0,0.25);
  letter-spacing: 0.6px;
  white-space: nowrap;
}
#comboBig.pulse{
  animation: comboPulse 0.38s ease-out;
}
@keyframes comboPulse{
  0%{ transform: translate(-50%, -50%) rotate(-2deg) scale(0.95); opacity: 0.0; }
  40%{ transform: translate(-50%, -50%) rotate(-2deg) scale(1.18); opacity: 1.0; }
  100%{ transform: translate(-50%, -50%) rotate(-2deg) scale(1.0); opacity: 0.95; }
}

/* SCREEN FLASH (milestone) */
#screenFlash{
  position: fixed;
  inset: 0;
  z-index: 93;
  display: none;
  pointer-events: none;
  background: rgba(255,255,255,0.0);
}
#screenFlash.flash{
  display: block;
  animation: flashPop 0.34s ease-out forwards;
}
@keyframes flashPop{
  0%{ background: rgba(255,255,255,0.0); }
  15%{ background: rgba(255,255,255,0.55); }
  100%{ background: rgba(255,255,255,0.0); }
}

/* COMBO panel (keep but hide: replaced by comboBig) */
#combo-panel{ display:none !important; }

    /* comboBig disabled (show combo only in FX) */
    #comboBig{ display:none !important; }
  
  .verBadge{
  position:fixed;
  top:calc(8px + env(safe-area-inset-top));
  left:calc(8px + env(safe-area-inset-left));
  right:auto;
  bottom:auto;
  padding:4px 8px;
  border-radius:999px;
  background:rgba(0,0,0,0.45);
  color:#fff;
  font-weight:800;
  font-size:12px;
  letter-spacing:.3px;
  z-index:9999;
  pointer-events:none;
  user-select:none;
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
}

  body:not(.isMenu) .verBadge{ display:none; }
/* === PAGE_FLIP_TRANSITION v1 (shared) === */
#pageFlip{
  position: fixed;
  inset: 0;
  z-index: 99999;
  pointer-events: none;
  display: none;
  perspective: 900px;
}
#pageFlip::before{
  content:"";
  position:absolute;
  inset: -6vh -8vw;
  background:
    linear-gradient(90deg,
      rgba(255,255,255,0.00) 0%,
      rgba(255,255,255,0.65) 35%,
      rgba(255,255,255,0.98) 62%,
      rgba(255,255,255,1.00) 100%);
  box-shadow: -18px 0 45px rgba(0,0,0,0.18);
  transform-origin: right center;
  transform: translateX(110%) rotateY(-35deg);
  border-left: 1px solid rgba(0,0,0,0.08);
}
#pageFlip.run::before{
  animation: pageFlipIn 320ms ease-out forwards;
}
@keyframes pageFlipIn{
  0%   { transform: translateX(110%) rotateY(-35deg); opacity: 0.0; }
  25%  { opacity: 1.0; }
  100% { transform: translateX(0%) rotateY(0deg); opacity: 1.0; }
}
@media (prefers-reduced-motion: reduce){
  #pageFlip.run::before{ animation: none; transform: translateX(0) rotateY(0); opacity: 1; }
}

/* ===== CLICK FIX (menu always clickable) ===== */
body.menuOpen #gameCanvas{ pointer-events:none; }
body.menuOpen #menu-overlay{ display:flex; z-index:10000; pointer-events:auto; }
body.menuOpen #menu-overlay *{ pointer-events:auto; }
body.playing #menu-overlay{ display:none; }

/* v7: hide top-left badges/buttons */
.verBadge{display:none !important;}
/* Hide chord debug HUD (user request) */
#chordHud{display:none !important;}

    /* menu preview: match "„Ç≥„Éº„Éâ „Åã„Çì„Åü„Çì" single-note label style */
    .menu-text{ display:flex; flex-direction:column; flex: 1 1 auto; min-width:0; }
    .menu-preview{ margin-top:6px; width:100%; }
    
@media (orientation: landscape) and (max-height: 430px){
  .mode-desc{ margin-top: 3px; font-size: 10px; }
  .mode-select .mode-pill{ padding: 5px 10px; font-size: 10px; box-shadow: 0 8px 14px rgba(0,0,0,0.10); }
}

/* === MENU_V6_FIX: song title overlap + pills match index === */

/* „Åç„Çâ„Åç„Çâ„Åº„ÅóÔºàÊõ≤ÔºâÔºö„Çπ„Éî„Éº„ÉâÈÅ∏Êäû„ÅØ„Éú„Çø„É≥Â§ñÔºàiOS„ÅßÁ¢∫ÂÆü„Å´ÈÅ∏„Åπ„Çã„Çà„ÅÜ„Å´Ôºâ */
.song-block{ display:flex; flex-direction:column; gap:6px; }
.song-block .song-speed-inline{
  display:flex; flex-direction:column; gap:4px;
  margin-left: 0; /* 2√ó2ÈÖçÁΩÆ„ÅÆ„Åü„ÇÅÂ∑¶ÂØÑ„Åõ */
  margin-top: 6px;
}
.song-block .song-speed-inline .mode-pills{ justify-content: flex-start !important; }
.song-speed-title{ font-size:11px; font-weight:900; opacity:.85; }
.song-speed-note{ font-size:11px; opacity:.75; }


/* „Éî„É´„Éú„Çø„É≥ÔºàÊõ≤„Çπ„Éî„Éº„Éâ/„É¢„Éº„ÉâÔºâ„ÇíTOP„Å®Âêå„Åò‚ÄúÁôΩ„Éî„É´‚Äù„Å´Áµ±‰∏Ä */
.mode-pill{
  background: rgba(255,255,255,0.78);
  border: 2px solid rgba(255,255,255,0.92);
  border-radius: 999px;
  box-shadow: 0 10px 18px rgba(0,0,0,0.10);
  padding: 7px 14px;
  font-weight: 1000;
  font-size: 11px;
  cursor: pointer;
  user-select: none;
}
.mode-pill.active{
  border-color: rgba(255,122,61,0.95);
  box-shadow: 0 10px 18px rgba(0,0,0,0.10), inset 0 0 0 2px rgba(255,122,61,0.12);
  color: rgba(255,122,61,1);
  background: rgba(255,255,255,0.92);
}

/* iPhoneÊ®™„ÅßË©∞„Åæ„ÇãÊôÇÔºö„Ç§„É≥„Éá„É≥„Éà„Å®„Éî„É´„ÇíÂ∞ë„ÅóÂ∞è„Åï„Åè */
@media (orientation: landscape) and (max-height: 430px){
  .song-block .song-speed-inline{ margin-left: 0 !important; }
  .mode-pill{ padding: 6px 12px; font-size: 10px; box-shadow: 0 8px 14px rgba(0,0,0,0.10); }
}


/* Tap sound volume */
.tap-vol-wrap{ margin-top: 14px; padding: 12px 14px; border-radius: 14px; background:#f6f7fb; }
.tap-vol-label{ font-weight: 900; font-size: 14px; margin-bottom: 8px; color:#333; }
#tapVol{
  width: 100%;
  height: 30px;
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  touch-action: none; /* drag smoothly */
}
#tapVol::-webkit-slider-runnable-track{
  height: 10px;
  border-radius: 999px;
  background: rgba(0,0,0,0.14);
}
#tapVol::-webkit-slider-thumb{
  -webkit-appearance: none;
  appearance: none;
  width: 34px;
  height: 34px;
  border-radius: 999px;
  background: #fff;
  border: 2px solid rgba(0,0,0,0.12);
  box-shadow: 0 6px 16px rgba(0,0,0,0.18);
  margin-top: -12px; /* center thumb on track */
}
#tapVol:active::-webkit-slider-thumb{
  transform: scale(1.04);
}
#tapVol::-moz-range-track{
  height: 10px;
  border-radius: 999px;
  background: rgba(0,0,0,0.14);
}
#tapVol::-moz-range-thumb{
  width: 34px;
  height: 34px;
  border-radius: 999px;
  background: #fff;
  border: 2px solid rgba(0,0,0,0.12);
  box-shadow: 0 6px 16px rgba(0,0,0,0.18);
}

    /* MENU_COLOR_PATCH v12 */
    .menu-btn.mode1{ background: linear-gradient(135deg, rgba(122,177,204,0.95), rgba(168,230,207,0.95)); }
    .menu-btn.mode2{ background: linear-gradient(135deg, rgba(255,222,89,0.96), rgba(255,183,71,0.94)); }
    .menu-btn.mode3{ background: linear-gradient(135deg, rgba(255,170,200,0.94), rgba(186,146,255,0.92)); }
    .menu-btn.mode4{ background: linear-gradient(135deg, rgba(178,235,127,0.92), rgba(255,222,89,0.92)); }
    .menu-btn{ color:#3b2a1f; box-shadow: 0 8px 0 rgba(0,0,0,0.10); }
    .menu-btn:active{ transform: translateY(2px); }
    .song-only-note{ font-size: 12px; opacity: 0.9; }
    /* keep menu inside viewport on iPhone landscape */
    .menu-card{ max-height: calc(100dvh - 24px); max-height: calc(var(--vh) * 100 - 24px); overflow-y: auto; }


/* SLIDER TOUCH FIX v5 */
#tapVol, input[type=range]{ touch-action: pan-x; }
#menuBackBtn{ position: sticky; bottom: 0; }


/* ===== V7 COMPACT: tap volume + TOP button fit in one screen ===== */
#verTag{
  display: none !important; /* v82: ÂÆåÂÖ®„Å´ÈùûË°®Á§∫Ôºà„É™„ÇØ„Ç®„Çπ„ÉàÂØæÂøúÔºâ */
  position: absolute;
  right: 14px;
  top: 14px;
  z-index: 5;
  padding: 4px 10px;
  border-radius: 999px;
  background: rgba(0,0,0,0.35);
  color: #fff;
  font-weight: 900;
  font-size: 12px;
  letter-spacing: .02em;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
#tap-vol-wrap{
  margin-top: 8px;
  background: rgba(255,255,255,0.70);
  border-radius: 18px;
  padding: 10px 14px 12px;
  box-shadow: 0 10px 20px rgba(0,0,0,0.08);
}
#tap-vol-wrap .tap-vol-label{
  font-weight: 1000;
  font-size: 14px;
  margin: 0 0 8px;
  opacity: .92;
}
#tapVol{
  width: 100%;
  height: 26px;
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  touch-action: pan-x; /* allow horizontal drag */
}
#tapVol::-webkit-slider-runnable-track{
  height: 10px;
  border-radius: 999px;
  background: rgba(0,0,0,0.16);
}
#tapVol::-webkit-slider-thumb{
  -webkit-appearance: none;
  appearance: none;
  width: 26px;
  height: 26px;
  border-radius: 999px;
  background: rgba(255,255,255,0.98);
  border: 3px solid rgba(255,122,61,0.95);
  box-shadow: 0 10px 18px rgba(0,0,0,0.18);
  margin-top: -8px; /* center on track */
}
#menuBackBtn{
  margin-top: 8px !important;
  padding: 12px 14px !important;
  font-size: 16px !important;
  border-radius: 18px !important;
}

/* iPhoneÊ®™„Åß1ÁîªÈù¢„Å´Âèé„ÇÅ„Çã */
@media (orientation: landscape) and (max-height: 430px){
  .menu-card{
    padding: 10px 10px calc(10px + env(safe-area-inset-bottom)) !important;
    gap: 6px !important;
    max-height: calc(100dvh - 10px) !important;
  }
  #tap-vol-wrap{
    margin-top: 6px;
    padding: 7px 10px 8px;
    border-radius: 16px;
  }
  #tap-vol-wrap .tap-vol-label{
    font-size: 12px;
    margin-bottom: 6px;
  }
  #tapVol{
    height: 22px;
  }
  #tapVol::-webkit-slider-runnable-track{
    height: 8px;
  }
  #tapVol::-webkit-slider-thumb{
    width: 22px;
    height: 22px;
    margin-top: -7px;
    border-width: 2px;
  }
  #menuBackBtn{
    margin-top: 6px !important;
    padding: 10px 12px !important;
    font-size: 15px !important;
  }
  #verTag{ top: 10px; right: 10px; font-size: 11px; }
}


/* ===== v8: Èü≥ÈáèÔºãTOP Ê®™‰∏¶„Å≥Ôºà1ÁîªÈù¢Âèé„ÇÅÔºâ ===== */
.bottom-inline{
  display:flex;
  align-items:center;
  gap:12px;
  margin-top:8px;
}
.vol-inline{
  flex:1;
  display:flex;
  align-items:center;
  gap:8px;
}
.vol-label{
  font-weight:900;
  font-size:12px;
  white-space:nowrap;
}
#tapVolume{
  flex:1;
  max-width:240px; /* Áü≠„Åè */
  height:24px;
  touch-action:pan-x;
}
.top-inline-btn{
  flex-shrink:0;
  padding:8px 14px;
  border-radius:999px;
  border:none;
  background:rgba(255,255,255,0.92);
  font-weight:900;
  font-size:13px;
  box-shadow:0 6px 14px rgba(0,0,0,.12);
}


/* ===== v9 hotfix: hide legacy duplicate blocks ===== */
#tap-vol-wrap,
#menuBackBtn,
.legacy-volume,
.legacy-top {
  display: none !important;
}


/* v23: UKE menu does NOT show volume slider (TOP button stays) */
body.is-uke .vol-inline{ display:none !important; }


/* v23 build badge (cache check) */
#buildBadge{
  position: fixed;
  top: 10px;
  left: 12px;
  z-index: 9999;
  padding: 4px 10px;
  border-radius: 999px;
  background: rgba(0,0,0,0.55);
  color: #fff;
  font-weight: 800;
  font-size: 12px;
  pointer-events: none;
  display: none !important; /* v81: ÂÆåÂÖ®Ê∂àÂéª */
}


/* v76: tapVolume drag stability (layout unchanged) */
#tapVolume{ touch-action: pan-x; }

/* === SAMPLER UI === */
#sampler-overlay {
  position: fixed; inset: 0; z-index: 10001;
  background: rgba(0,0,0,0.65);
  backdrop-filter: blur(8px);
  display: none;
  flex-direction: column;
  align-items: center; justify-content: center;
}
.sampler-card {
  width: min(500px, 92vw);
  background: #fff;
  border-radius: 24px;
  padding: 24px;
  text-align: center;
  box-shadow: 0 20px 50px rgba(0,0,0,0.3);
  display: flex; flex-direction: column; gap: 14px;
}
.sampler-title { font-size: 20px; font-weight: 900; color: #4a3728; margin: 0; }
.sampler-text { font-size: 15px; opacity: 0.8; line-height: 1.5; font-weight: 700; margin: 4px 0 10px; }
.sampler-meter {
  height: 12px; width: 100%; background: #eee; border-radius: 6px; overflow: hidden;
  position: relative; margin-bottom: 10px;
}
.sampler-bar {
  height: 100%; width: 0%; background: var(--primary);
  transition: width 0.1s linear;
}
.sampler-btn-row { display: flex; gap: 12px; margin-top: 6px; }
.btn-outline { background: #fff; border: 2px solid #ddd; color: #555; }
</style>

<style>
  /* Force-landscape UX: block portrait with a friendly overlay */
  #landscapeLock{
    position: fixed; inset: 0;
    display: none;
    align-items: center; justify-content: center;
    z-index: 2147483647;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    padding: 18px;
    box-sizing: border-box;
  }
  body.needLandscape #landscapeLock{ display:flex; }
  .landscapeCard{
    width: min(560px, 92vw);
    border-radius: 22px;
    background: rgba(255,255,255,0.92);
    box-shadow: 0 18px 50px rgba(0,0,0,0.25);
    padding: 18px 18px 16px;
    text-align: center;
    color: #2b2b2b;
  }
  .landscapeRow{
    display:flex; gap: 14px; align-items:center; justify-content:center;
    margin-bottom: 10px;
    flex-wrap: wrap;
  }
  .rabbit{
    font-size: 44px; line-height: 1;
    filter: drop-shadow(0 6px 10px rgba(0,0,0,0.15));
  }
  .phone{
    font-size: 42px; line-height: 1;
    transform: rotate(-18deg);
  }
  .landscapeTitle{
    font-weight: 1000;
    font-size: 24px;
    margin: 6px 0 8px;
  }
  .landscapeText{
    font-weight: 900;
    font-size: 18px;
    margin: 0;
    opacity: .92;
  }
  .landscapeHint{
    margin-top: 10px;
    font-size: 13px;
    font-weight: 800;
    opacity: .75;
  }
  @media (max-height: 430px){
    .landscapeTitle{ font-size: 20px; }
    .landscapeText{ font-size: 16px; }
    .rabbit{ font-size: 38px; }
    .phone{ font-size: 36px; }
  }

/* SLIDER TOUCH FIX v5 */
#tapVol, input[type=range]{ touch-action: pan-x; }
#menuBackBtn{ position: sticky; bottom: 0; }

</style>

</head>
<body class="menuOpen">
<div id="app">
<div id="menu-overlay">
<div class="menu-card">
<h1 id="menuTitle" style="margin-bottom: 2px;">ü™ï „Ç¶„ÇØ„É¨„É¨„Åß„ÅÇ„Åù„Å∂</h1>
<div id="verTag">v0.5 Sample</div>
<div class="menu-list" style="display:flex; flex-direction:column; gap:8px;">
<div class="menu-main">
  <button class="menu-btn mode1" onclick="prepGame('scale')">
    <div class="badge">üê§</div>
    <div class="menu-text">
      <div class="title">„Éâ„É¨„Éü„Éï„Ç°„ÇΩ„É©„Ç∑„Éâ</div>
      <small>„Å†„Çì„Å†„ÇìÈÄü„Åè„Å™„Çã„Çà</small>
    </div>
  </button>
  <button class="menu-btn mode2" onclick="prepGame('easy')">
    <div class="badge">üê±</div>
    <div class="menu-text"><div class="title">„Ç≥„Éº„Éâ „Åã„Çì„Åü„Çì</div><small>C / F / G7 / Am</small></div>
  </button>
  <button class="menu-btn mode3" onclick="prepGame('hard')">
    <div class="badge">üêº</div>
    <div class="menu-text"><div class="title">„Ç≥„Éº„Éâ „Å°„Çá„ÅÑ„ÇÄ„Åö</div><small>„ÅÑ„Çç„ÅÑ„Çç„Å™„Ç≥„Éº„Éâ</small></div>
  </button>
  <div class="song-block">
    <button class="menu-btn mode4 song-start" onclick="prepGame('song')" aria-label="„Åç„Çâ„Åç„Çâ„Åº„Åó„Çí„ÅØ„Åò„ÇÅ„Çã">
      <div class="badge">ü¶Å</div>
      <div class="menu-text"><div class="title song-title">„Åç„Çâ„Åç„Çâ„Åº„Åó</div><small>„É°„É≠„Éá„Ç£Ôºã„Ç≥„Éº„Éâ</small></div>
    </button>
    <div class="song-speed-inline" id="song-speed-wrap">
      <div class="song-speed-title">‚ô™ „Åç„Çâ„Åç„Çâ„Åº„Åó„ÅÆÈÄü„Åï <span class="song-only-note">(„Åì„ÅÆÊõ≤„Å†„Åë)</span></div>
      <div class="mode-pills" id="song-speed-pills" style="justify-content:flex-start; flex-wrap:wrap; gap:6px;">
        <div class="mode-pill" data-ss="SLOW">„ÇÜ„Å£„Åè„Çä</div>
        <div class="mode-pill active" data-ss="NORMAL">„Åµ„Å§„ÅÜ</div>
        <div class="mode-pill" data-ss="FAST">„ÅØ„ÇÑ„ÅÑ</div>
      </div>
      <div id="song-speed-note" class="song-speed-note">‚Äª„Åì„ÅÆË®≠ÂÆö„ÅØ„Äå„Åç„Çâ„Åç„Çâ„Åº„Åó„Äç„Å†„Åë„Å´Âäπ„Åç„Åæ„Åô</div>
    </div>
  </div>
</div>
</div>
<div class="mode-select">
  <div class="settings-row">
    <div class="settings-box" id="sound-box">
      <div class="sound-select-wrap" id="sound-toggle-wrap" style="display:none;">
          <div class="sound-label">‚ô™ „Ç¶„ÇØ„É¨„É¨„ÅÆ„Åä„Å®</div>
          <div class="mode-pills" id="sound-src-pills">
            <div class="mode-pill active" id="btn-sound-synth" onclick="toggleSoundSource('synth')">ÈõªÂ≠êÈü≥</div>
            <div class="mode-pill" id="btn-sound-sample" onclick="toggleSoundSource('sample')">Èå≤Èü≥„Åó„ÅüÈü≥</div>
          </div>
      </div>
    </div>

    <div class="settings-box" id="mode-box">
      <div class="mode-pills" id="play-mode-pills">
        <div class="mode-pill" data-mode="NORMAL" onclick="setMode(this, 'NORMAL')">„Éé„Éº„Éû„É´</div>
        <div class="mode-pill active" data-mode="WAIT" onclick="setMode(this, 'WAIT')">„Çµ„Éù„Éº„Éà‰ªò„Åç</div>
      </div>
      <div id="mode-desc" class="mode-desc">„Çµ„Éù„Éº„Éà‰ªò„ÅçÔºö„Å®„Åæ„Å£„Å¶ „Åæ„Å§„ÇàÔºà„ÅØ„Åò„ÇÅ„Å¶„Å´„Åä„Åô„Åô„ÇÅÔºâ</div>
    </div>
  </div>

  <div class="tap-vol-wrap" id="tap-vol-wrap">
    <div class="tap-vol-label">üîä „Çø„ÉÉ„ÉóÈü≥„ÅÆÂ§ß„Åç„Åï</div>
    <input id="tapVol" type="hidden" min="0" max="100" value="35" />
  </div>
</div>

<button id="menuBackBtn" class="action-btn btn-secondary" onclick="goBackFromGameMenu()" style="margin-top:10px;">üèùÔ∏è TOP„Å∏„ÇÇ„Å©„Çã</button>

<div class="bottom-inline">
  <div class="vol-inline">
    <div class="vol-label">üîä „Çø„ÉÉ„ÉóÈü≥</div>
    <input id="tapVolume" type="range" min="0" max="1" step="0.01" value="0.5">
  </div>
  <button class="top-inline-btn" onclick="goFlip('index.html')">üèùÔ∏è TOP„Å∏„ÇÇ„Å©„Çã</button>
</div>
</div>
</div>
<div id="screenFlash"></div>
<div id="screenRainbow"></div>
<div id="fxMsg"></div>
<div id="comboBig"></div>
<div id="lyrics-area"></div>
<div id="combo-panel"><div class="t1">COMBO</div><div class="t2"><span id="comboNum">0</span> ÈÄ£Á∂ö</div></div>
<div id="score-panel">‚≠ê <span id="score">0</span></div>
<div id="timer-panel">„ÅÆ„Åì„Çä <span id="timer">60</span> Áßí</div>
<div aria-hidden="true" id="chordHud"></div>
<div id="back-btn"><button onclick="goMenu()">üèùÔ∏è „É°„Éã„É•„Éº</button></div>
<button id="stopBtn" type="button">„Çπ„Éà„ÉÉ„Éó</button>
<div class="overlay-card" id="loading-overlay">
<div class="card-content">
<h2>„Éû„Ç§„ÇØ„Åò„ÇÖ„Çì„Å≥‰∏≠...</h2>
<p id="loading-msg">Èùô„Åã„Å´„Åó„Å¶„Å≠Ôºà„Éé„Ç§„Ç∫„Çí„ÅØ„Åã„Å£„Å¶„ÅÑ„Åæ„ÅôÔºâ</p>
</div>
</div>
<div class="overlay-card" id="pause-overlay">
<div class="card-content">
<h2>„Çπ„Éà„ÉÉ„Éó‰∏≠</h2>
<button class="action-btn btn-primary" onclick="resumeGame()">„Å§„Å•„Åë„Çã</button>
<button class="action-btn btn-secondary" onclick="goMenu()">„É°„Éã„É•„Éº„Å∏</button>
</div>
</div>
<div class="overlay-card" id="result-overlay">
<div class="card-content">
<h2>Finish!</h2>
<div class="result-score">‚≠ê <span id="result-score">0</span> pts</div>
<p id="result-msg">Good Job!</p>
<button class="action-btn btn-primary" onclick="restartLast()">„ÇÇ„ÅÜÔºëÂõû</button>
<button class="action-btn btn-secondary" onclick="goMenu()">„É°„Éã„É•„Éº</button>
</div>
</div>

<div id="sampler-overlay">
  <div class="sampler-card">
    <h2 class="sampler-title" id="samplerTitle">„Ç¶„ÇØ„É¨„É¨Èå≤Èü≥</h2>
    <div class="sampler-text" id="samplerMsg">„ÅÇ„Å™„Åü„ÅÆ„Ç¶„ÇØ„É¨„É¨„ÅÆÈü≥„ÇíÈå≤Èü≥„Åó„Å¶<br>„Ç≤„Éº„É†„ÅÆÈü≥„Å´‰Ωø„ÅÑ„Åæ„Åô„ÅãÔºü</div>
    <div class="sampler-meter" id="samplerMeterBox" style="display:none;"><div class="sampler-bar" id="samplerBar"></div></div>
    <div class="sampler-btn-row" id="samplerBtns">
      <button class="action-btn btn-secondary" onclick="skipSampling()">„Çπ„Ç≠„ÉÉ„Éó</button>
      <button class="action-btn btn-primary" onclick="startSamplerFlow()">Èå≤Èü≥„Åô„ÇãÔºÅ</button>
    </div>
  </div>
</div>

<canvas id="gameCanvas"></canvas>
</div>
<script>

// --- v28: prevent iOS/PC page scrolling & double-tap zoom during play ---
(function preventPageScroll(){
  const opts = { passive: false };

  // Allow native interactions for range sliders / menu controls
  const allowNative = (e)=>{
    const t = e && e.target;
    if(!t) return false;
    // range itself or anything inside tap volume UI should be native
    try{
      if(t.matches && t.matches('input[type="range"], input[type="range"] *')) return true;
      if(t.closest && t.closest('#tap-vol-wrap')) return true;
      if(t.closest && t.closest('#menu-overlay')) return true; // menu should not be blocked
    }catch(_){}
    return false;
  };

  const stop = (e)=>{
    if(allowNative(e)) return;
    try{ e.preventDefault(); }catch(_){}
  };

  // During MENU, allow normal interactions; during PLAY, block page scroll.
  document.addEventListener('touchmove', (e)=>{
    if(gameState !== 'PLAY') return;
    stop(e);
  }, opts);

  document.addEventListener('gesturestart', stop, opts);
  document.addEventListener('gesturechange', stop, opts);
  document.addEventListener('gestureend', stop, opts);

  document.addEventListener('wheel', (e)=>{
    if(gameState==='PLAY') stop(e);
  }, opts);
})();


// ===== MENU CLICK FIX =====
(function(){
  const body = document.body;
  const menu = document.getElementById('menu-overlay');
  if (!body || !menu) return;

  // Start in menu state
  body.classList.add('menuOpen');

  function handler(ev){
    const btn = ev.target && ev.target.closest ? ev.target.closest('button') : null;
    if (!btn) return;
    const oc = btn.getAttribute('onclick') || '';
    let m = oc.match(/prepGame\('([^']+)'\)/);
    if (m && typeof window.prepGame === 'function'){
      ev.preventDefault();
      ev.stopPropagation();
      window.prepGame(m[1]);
      return;
    }
    // fallback: evaluate inline handlers for other buttons
    if (oc){
      ev.preventDefault();
      ev.stopPropagation();
      try { Function(oc).call(btn); } catch(e) {}
    }
  }
  menu.addEventListener('click', handler, true);

  // Wrap goMenu / prepGame to toggle menuOpen state reliably
  const _prep = window.prepGame;
  if (typeof _prep === 'function'){
    window.prepGame = function(mode){
      body.classList.remove('menuOpen');
      return _prep.call(this, mode);
    };
  }
  const _goMenu = window.goMenu;
  if (typeof _goMenu === 'function'){
    window.goMenu = function(){
      body.classList.add('menuOpen');
      return _goMenu.call(this);
    };
  }
})();


// ===== SONG SPEED PRESET (Êõ≤„É¢„Éº„ÉâÔºöÊúÄÂàù„Å´„Çπ„Éî„Éº„ÉâÂõ∫ÂÆö) =====
const SONG_SPEED_KEY = 'uk_song_speed_v1';
const SONG_SPEED_PRESETS = { SLOW: 2.55, NORMAL: 5.10, FAST: 10.20 }; 
function getSongSpeedId(){
  try{
    const v = localStorage.getItem(SONG_SPEED_KEY);
    return (v && SONG_SPEED_PRESETS[v]) ? v : 'NORMAL';
  }catch(e){ return 'NORMAL'; }
}
function setSongSpeedId(id){
  if(!SONG_SPEED_PRESETS[id]) id='NORMAL';
  try{ localStorage.setItem(SONG_SPEED_KEY, id); }catch(e){}
  // UI reflect
  const wrap = document.getElementById('song-speed-pills');
  if(wrap){
    [...wrap.querySelectorAll('.mode-pill')].forEach(p=>p.classList.toggle('active', p.dataset.ss===id));
  }
}
function getSongSpeedBase(){
  return SONG_SPEED_PRESETS[getSongSpeedId()] || SONG_SPEED_PRESETS.NORMAL;
}
function bindSongSpeedUI(){
  const wrap = document.getElementById('song-speed-pills');
  if(!wrap) return;

  const pick = (ev)=>{
    const pill = ev.target && ev.target.closest ? ev.target.closest('.mode-pill') : null;
    if(!pill) return;
    try{ ev.preventDefault(); }catch(e){}
    try{ ev.stopPropagation(); }catch(e){}
    setSongSpeedId(pill.dataset.ss);
  };

  wrap.addEventListener('pointerdown', pick, {passive:false, capture:true});
  wrap.addEventListener('touchstart',  pick, {passive:false, capture:true});
  wrap.addEventListener('mousedown',   pick, true);
  wrap.addEventListener('click',       pick, true);

  setSongSpeedId(getSongSpeedId());
}

// ===== Âü∫Êú¨Ë®≠ÂÆö =====
const BASE_SPEED_MULT = 1.15; 
const SPEEDUP_MULT = 1.25;     
const PRACTICE_BOOST_CAP = 100; 

const ENABLE_SPEED_UP = false; 
const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ===== SHARED_STAGE_BLOCK v1 (GAME/TUNING ÂÖ±ÈÄö) =====
const STAGE = Object.freeze({
  NUT_X: 150,
  NECK_HALF_H: 130,
  NECK_H: 260,
  FRET_COUNT: 12,
  FRET_RIGHT_PAD: 20,       
  LANE_DY: 75,
  LABEL_X: 110,
  LABEL_R: 22,
  NUT_LINE_W: 10,
  FRET_LINE_W: 3,
  STRING_LINE_W: 6,
  NUT_COLOR: "#eee",
  FRET_COLOR: "#a1887f",
  FRET_MARK_COLOR: "#c9b7ae",
  FRET_MARK_W_MULT: 1.3,
  INLAY_COLOR: "rgba(255,255,255,0.28)",
  INLAY_STROKE: "rgba(0,0,0,0.15)",
  INLAY_R: 6,
  INLAY_DY: 16,
  NECK_COLOR: "#6d4c41",
  LABEL_FONT: "bold 16px sans-serif",
  NUT_BLOCK_W: 18,
  NUT_BLOCK_OVER: 6,
  FRET_HINTS: Object.freeze([1,3,5,7,10,12]),
  FRET_HINT_FONT: "700 13px sans-serif",
  FRET_HINT_COLOR: "rgba(255,255,255,0.62)",
  FRET_HINT_Y_PAD:  2,
});

function stageGeom(canvas){
  const cy = canvas.height/2;
  const nutX = STAGE.NUT_X;
  const fretW = (canvas.width - nutX - STAGE.FRET_RIGHT_PAD) / STAGE.FRET_COUNT;
  const y = cy - STAGE.NECK_HALF_H;
  const h = STAGE.NECK_H;
  return { cy, nutX, fretW, y, h };
}

function rrRect(ctx,x,y,w,h,r){
  r = Math.max(0, Math.min(r, w/2, h/2));
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function drawFretboardBase(ctx, canvas, stringColors){
  const g = stageGeom(canvas);
  const { cy, nutX, fretW } = g;

  // neck
  ctx.fillStyle = STAGE.NECK_COLOR;
  ctx.fillRect(nutX, cy - STAGE.NECK_HALF_H, canvas.width - nutX, STAGE.NECK_H);

  // nut block
  (function(){
    const nutW = STAGE.NUT_BLOCK_W;
    const over = STAGE.NUT_BLOCK_OVER;
    const x0 = nutX - nutW/2;
    const y0 = cy - STAGE.NECK_HALF_H - over;
    const h0 = STAGE.NECK_H + over*2;
    ctx.save();
    ctx.shadowColor = "rgba(0,0,0,0.25)";
    ctx.shadowBlur = 6;
    ctx.fillStyle = STAGE.NUT_COLOR;
    rrRect(ctx, x0, y0, nutW, h0, 6);
    ctx.fill();
    ctx.restore();
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = 2;
    rrRect(ctx, x0, y0, nutW, h0, 6);
    ctx.stroke();
  })();

  for (let i=1; i<=STAGE.FRET_COUNT; i++){
    const x = nutX + g.fretW * i;
    const isMark = (i===5 || i===10);

    ctx.strokeStyle = isMark ? STAGE.FRET_MARK_COLOR : STAGE.FRET_COLOR;
    ctx.lineWidth = STAGE.FRET_LINE_W * (isMark ? STAGE.FRET_MARK_W_MULT : 1);

    ctx.beginPath();
    ctx.moveTo(x, g.y);
    ctx.lineTo(x, g.y + g.h);
    ctx.stroke();

    if(i===5){
      ctx.save();
      ctx.fillStyle = STAGE.INLAY_COLOR;
      ctx.strokeStyle = STAGE.INLAY_STROKE;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(x, cy, STAGE.INLAY_R, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }else if(i===10){
      ctx.save();
      ctx.fillStyle = STAGE.INLAY_COLOR;
      ctx.strokeStyle = STAGE.INLAY_STROKE;
      ctx.lineWidth = 1;
      const dy = STAGE.INLAY_DY;
      for(const yy of [cy - dy, cy + dy]){
        ctx.beginPath();
        ctx.arc(x, yy, STAGE.INLAY_R, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  // teacher fret hints
  (function(){
    ctx.save();
    ctx.font = STAGE.FRET_HINT_FONT;
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom"; 
    const yTxt = g.y - 4;
    ctx.fillStyle = "#fff"; 
    for (const n of STAGE.FRET_HINTS){
      if (n < 1 || n > STAGE.FRET_COUNT) continue;
      const x = nutX + g.fretW * n;
      const s = String(n);
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.3)";
      ctx.beginPath();
      ctx.arc(x, yTxt - 7, 12, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      ctx.fillText(s, x, yTxt);
    }
    ctx.restore();
  })();

  const labs = ['1A','2E','3C','4G'];
  for(let i=0;i<4;i++){
    const y = cy + (i-1.5) * STAGE.LANE_DY;
    ctx.beginPath();
    ctx.fillStyle = stringColors[i];
    ctx.globalAlpha = 1.0;
    ctx.arc(STAGE.LABEL_X, y, STAGE.LABEL_R, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = STAGE.LABEL_FONT;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(labs[i], STAGE.LABEL_X, y);
    ctx.strokeStyle = stringColors[i];
    ctx.lineWidth = STAGE.STRING_LINE_W;
    ctx.beginPath();
    ctx.moveTo(nutX, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
  ctx.textAlign = "start";
  ctx.textBaseline = "alphabetic";
  return g; 
}

function updateUiVars(){
  const vv = window.visualViewport;
  if(vv){
    const top = Math.max(0, vv.offsetTop||0);
    const left = Math.max(0, vv.offsetLeft||0);
    const right = Math.max(0, (window.innerWidth - vv.width - left));
    const bottom = Math.max(0, (window.innerHeight - vv.height - top));
    document.documentElement.style.setProperty('--ui-top', Math.round(top)+'px');
    document.documentElement.style.setProperty('--ui-left', Math.round(left)+'px');
    document.documentElement.style.setProperty('--ui-right', Math.round(right)+'px');
    document.documentElement.style.setProperty('--ui-bottom', Math.round(bottom)+'px');
  } else {
    document.documentElement.style.setProperty('--ui-top','0px');
    document.documentElement.style.setProperty('--ui-left','0px');
    document.documentElement.style.setProperty('--ui-right','0px');
    document.documentElement.style.setProperty('--ui-bottom','0px');
  }
}
updateUiVars();
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', updateUiVars);
  window.visualViewport.addEventListener('scroll', updateUiVars);
}
window.addEventListener('resize', updateUiVars);
window.addEventListener('orientationchange', ()=>setTimeout(updateUiVars, 250));


let gameState = 'MENU';
let playMode = 'WAIT';
let useSampledSound = false; // Toggle state

// ===== TAP SOUND (hit SE) =====
const TAP_VOL_KEY = 'uk_tap_vol_v1';
let tapVol = 0.35;
let tapAudioCtx = null;
let tapMaster = null;
let tapCompressor = null; 

function loadTapVol(){
  try{
    const v = Number(localStorage.getItem(TAP_VOL_KEY));
    if(!Number.isNaN(v) && v>=0 && v<=1) tapVol = v;
  }catch(e){}
}
function saveTapVol(){
  try{ localStorage.setItem(TAP_VOL_KEY, String(tapVol)); }catch(e){}
}

function playSliderFeedback(){
  // Pop sound for slider feedback
  try{
    ensureTapAudio();
    const osc = tapAudioCtx.createOscillator();
    const gain = tapAudioCtx.createGain();
    osc.connect(gain);
    gain.connect(tapMaster);
    
    osc.frequency.setValueAtTime(880, tapAudioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(440, tapAudioCtx.currentTime + 0.1);
    
    gain.gain.setValueAtTime(0.5, tapAudioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, tapAudioCtx.currentTime + 0.1);
    
    osc.start();
    osc.stop(tapAudioCtx.currentTime + 0.15);
  }catch(e){}
}

function ensureTapAudio(){
  try{
    if(!tapAudioCtx) tapAudioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if(tapAudioCtx.state === 'suspended') tapAudioCtx.resume();
    
    if(!tapMaster){
      tapMaster = tapAudioCtx.createGain();
      tapCompressor = tapAudioCtx.createDynamicsCompressor();
      
      tapCompressor.threshold.setValueAtTime(-18, tapAudioCtx.currentTime);
      tapCompressor.knee.setValueAtTime(30, tapAudioCtx.currentTime);
      tapCompressor.ratio.setValueAtTime(12, tapAudioCtx.currentTime);
      tapCompressor.attack.setValueAtTime(0.003, tapAudioCtx.currentTime);
      tapCompressor.release.setValueAtTime(0.25, tapAudioCtx.currentTime);

      tapMaster.gain.value = tapVol;
      
      tapMaster.connect(tapCompressor);
      tapCompressor.connect(tapAudioCtx.destination);
      
      applyTapVolumeToGain();
    } else {
      tapMaster.gain.value = tapVol;
    }
  }catch(e){}
}

function enhanceRangeSlider(el, onSet){
  if(!el) return;
  const toNum = (x, fallback)=>{ const n = Number(x); return Number.isFinite(n) ? n : fallback; };
  const getStep = ()=>{ const s = String(el.step || '').trim(); if(!s || s === 'any') return null; const n = Number(s); return (Number.isFinite(n) && n > 0) ? n : null; };
  const snap = (v)=>{ const st = getStep(); if(!st) return v; const min = toNum(el.min, 0); return Math.round((v - min)/st)*st + min; };
  const clamp = (v)=>{ const min = toNum(el.min, 0); const max = toNum(el.max, 100); return Math.min(max, Math.max(min, v)); };
  const clamp01 = (v)=> Math.min(1, Math.max(0, v));

  const fireInput = ()=>{
    el.dispatchEvent(new Event('input', {bubbles:true}));
    el.dispatchEvent(new Event('change', {bubbles:true}));
  };

  const setByClientX = (clientX)=>{
    const rect = el.getBoundingClientRect();
    const min = toNum(el.min, 0), max = toNum(el.max, 100);
    const ratio = (clientX - rect.left) / Math.max(1, rect.width);
    let v = min + clamp01(ratio) * (max - min);
    v = clamp(snap(v));
    el.value = String(v);
    fireInput();
    if(typeof onSet === 'function'){
      try{ onSet(v); }catch(_e){}
    }
  };

  // Pointer & touch events (smooth on iPhone Safari landscape)
  let dragging = false;
  const start = (e)=>{
    dragging = true;
    if(e && e.preventDefault) e.preventDefault();
    const x = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    setByClientX(x);
  };
  const move = (e)=>{
    if(!dragging) return;
    if(e && e.preventDefault) e.preventDefault();
    const x = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    setByClientX(x);
  };
  const end = ()=>{ dragging = false; };

  el.addEventListener('pointerdown', start, {passive:false});
  window.addEventListener('pointermove', move, {passive:false});
  window.addEventListener('pointerup', end);
  window.addEventListener('pointercancel', end);

  el.addEventListener('touchstart', start, {passive:false});
  window.addEventListener('touchmove', move, {passive:false});
  window.addEventListener('touchend', end);
  window.addEventListener('touchcancel', end);
}

function bindTapVolUI(){
  loadTapVol();
  const el = document.getElementById('tapVol');
  if(!el) return;
  el.value = String(Math.round(tapVol * 100));
  enhanceRangeSlider(el);
  const apply = ()=>{
    tapVol = Math.max(0, Math.min(1, Number(el.value)/100));
    if(tapMaster) tapMaster.gain.value = tapVol;
    saveTapVol();
    ensureTapAudio();
  };
  el.addEventListener('input', apply);
  el.addEventListener('change', apply);
}


// „Éû„Ç§„ÇØÈñ¢ÈÄ£
let audioCtx = null;
let micStream = null;
let micAnalyser = null;

// ---- „ÉÅ„É•„Éº„Éã„É≥„Ç∞ÁµêÊûúÔºàÂà§ÂÆöÈñæÂÄ§Ôºâ„ÇíË™≠„ÇÄ ----
const THRESH_KEY = 'uk_game_thresholds_v1';
const THRESH_MAX_AGE_H = 24; 
function loadGameThresholds(){
  try{
    const raw = localStorage.getItem(THRESH_KEY);
    if(!raw) return null;
    const o = JSON.parse(raw);
    if(!o || typeof o !== 'object') return null;
    if(!o.updatedAt) return null;
    const ageH = (Date.now() - Number(o.updatedAt)) / 3600000;
    if(!(ageH >= 0) || ageH > THRESH_MAX_AGE_H) return null;
    return o;
  }catch(e){ return null; }
}
async function measureNoiseRms(durationMs=900, stepMs=90){
  if(!micAnalyser) return 0;
  const buf = new Float32Array(micAnalyser.fftSize);
  const samples = [];
  const end = performance.now() + durationMs;
  while(performance.now() < end){
    micAnalyser.getFloatTimeDomainData(buf);
    let s=0; for(let i=0;i<buf.length;i++) s += buf[i]*buf[i];
    samples.push(Math.sqrt(s/buf.length));
    await new Promise(r=>setTimeout(r, stepMs));
  }
  samples.sort((a,b)=>a-b);
  const idx = Math.max(0, Math.min(samples.length-1, Math.floor(samples.length*0.85)));
  return samples[idx] ?? (samples[samples.length-1] ?? 0);
}
function applyThresholdsFrom(noise, stored){
  let rise = 0, high = 0;
  if(stored && typeof stored.pluckRiseRms === 'number' && typeof stored.pluckHighRms === 'number'){
    const baseNoise = (typeof stored.noiseRms==='number' && stored.noiseRms>0) ? stored.noiseRms : noise;
    const k = baseNoise>0 ? (noise/baseNoise) : 1;
    rise = stored.pluckRiseRms * k;
    high = stored.pluckHighRms * k;
  }
  if(IS_IOS){
    rise = Math.max(rise||0, 0.0016, noise*2.0);
    high = Math.max(high||0, 0.0020, noise*3.0);
  } else {
    rise = Math.max(rise||0, 0.010,  noise*2.0);
    high = Math.max(high||0, 0.012,  noise*3.0);
  }
  if(high < noise*2.4) high = noise*2.4;
  if(rise > high*0.9) rise = high*0.6;
  PLUCK_RISE_RMS = rise;
  PLUCK_HIGH_RMS = high;
}

let prevRms = 0;
let pluckHoldCount = 0;
let ignorePluckUntil = 0;
let NOISE_RMS = 0;
let PLUCK_HIGH_RMS = 0.012; 
let PLUCK_RISE_RMS = 0.010;

// „Ç≤„Éº„É†Â§âÊï∞
let rafId = 0;
let gameEndAt = 0;
let score = 0;
let groups = [];
let stars = [];
const STAR_CAP = 90; 
function burstStars(n, x, y, waves=1, waveDelay=120){
  if(IS_IOS) n = Math.min(n, 8);
  const make = ()=>{
    const add = Math.min(n, STAR_CAP);
    for(let i=0;i<add;i++) stars.push(new Star(x,y));
    if(stars.length > STAR_CAP) stars.splice(0, stars.length-STAR_CAP);
  };
  make();
  for(let w=1; w<waves; w++) setTimeout(make, waveDelay*w);
}


function getNeckMidY(){
  try{ return (canvas.height/2) + (0.0)*STAGE.LANE_DY; }catch(e){ return (window.innerHeight/2); }
}
function getFxPointFromGroup(g){
  try{
    const x = (g && typeof g.getAnchorX === 'function') ? g.getAnchorX() : (g && g.x != null ? g.x : (NUT_X+260));
    const y = getNeckMidY();
    return {x,y};
  }catch(e){
    return {x: (typeof NUT_X!=='undefined'? NUT_X+260 : (window.innerWidth*0.45)), y: (window.innerHeight*0.55)};
  }
}
let lastSpawn = 0;
let scrollSpeed = 3.5;
let baseScrollSpeed = 3.5;
let gameMode = 'practice';
let isSongMode = false;
let waitHold = false;
let waitTargetGroup = null;
let comboStreak = 0;
let speedLevel = 0;
let disableSpeedUpActive = false; 
let speedBoosted = false;
let practiceBoostCount = 0; 
let scaleSeqCount = 0;         
let scaleSpeedBoosted = false; 
  updateComboUI();
  const big=document.getElementById('comboBig'); if(big) big.style.display='none';
let currentScrollSpeed = 3.5;
const SPEED_UP_EVERY = 5;    
const SPEED_STEP = 0.5;   

let _fxTimer = 0;
const CHEER_PHRASES = ['„Åù„ÅÆË™øÂ≠êÔºÅ','„ÅÑ„ÅÑ„ÅûÔºÅ','„Éä„Ç§„ÇπÔºÅ','„ÅÑ„ÅÑÈü≥ÔºÅ','Êåá„Å∞„Å£„Å°„ÇäÔºÅ','„É™„Ç∫„É†ÂÆåÁíßÔºÅ','„Éé„Å£„Å¶„ÇãÔºÅ','„Ç≠„Çø„ÉºÔºÅ','ÊúÄÈ´òÔºÅ','„Å§„Å•„ÅëÔºÅ','„ÅÑ„Åë„ÇãÔºÅ','ËêΩ„Å°ÁùÄ„ÅÑ„Å¶„ÅÑ„Åì„ÅÜÔºÅ','‰ªä„ÅÆ„Åç„Çå„ÅÑÔºÅ'];
function flashScreen(){
  const f = document.getElementById('screenFlash');
  if(!f) return;
  f.classList.remove('flash');
  void f.offsetWidth;
  f.classList.add('flash');
}

function triggerRainbowFlash(){
  const r = document.getElementById('screenRainbow');
  if(!r) return;
  r.classList.remove('active');
  void r.offsetWidth;
  r.classList.add('active');
}

function showTimeBonus(msg){
  const el = document.createElement('div');
  el.className = 'time-bonus';
  el.textContent = msg;
  document.body.appendChild(el);
  setTimeout(()=>{ el.remove(); }, 1500);
}

function updateComboUI(){ /* disabled */ }

const PANDA_HINT_ENABLED = false; 

const _PANDA_LINES = ["„ÅÇ„Çè„Å¶„Å™„Åè„Å¶Â§ß‰∏àÂ§´","‰ªä„ÅÆ„ÅØÊ∞ó„Å´„Åó„Å™„ÅÑ","Ê¨°„ÅÑ„Åì„ÅÜ„ÄÅÊ¨°","„É™„Ç∫„É†„ÅØ„Åù„ÅÆ„Åæ„Åæ","„ÇÜ„Å£„Åè„Çä„ÅßOK"];

function showPandaHint(msg){
  if(!PANDA_HINT_ENABLED) return;
  const el = document.getElementById('pandaHint');
  if(!el) return;
  el.textContent = "üêº " + msg;
  el.style.opacity = "1";
  clearTimeout(el._t);
  el._t = setTimeout(()=>{ el.style.opacity = "0"; }, 3000);
}

function showFx(text, kind, opts = {}){
  const el = document.getElementById('fxMsg');
  if(!el) return;
  el.textContent = text;
  try{
    const px = (canvas ? canvas.width/2 : window.innerWidth/2);
    const py = (canvas ? canvas.height/2 : window.innerHeight/2) - 90;
    el.style.left = px + 'px';
    el.style.top  = py + 'px';
    el.style.transform = 'translate(-50%,-50%)';
  }catch(e){}
  
  if(PANDA_HINT_ENABLED && kind === 'miss'){
    try{
      const line = _PANDA_LINES[Math.floor(Math.random()*_PANDA_LINES.length)];
      showPandaHint(line);
    }catch(e){}
  }
el.classList.remove('hit','miss','speed','mega','show');
  el.style.display = 'block';
  if(kind) el.classList.add(kind);
  if(opts.mega) el.classList.add('mega');
  requestAnimationFrame(()=>{ el.classList.add('show'); });
  clearTimeout(_fxTimer);
  _fxTimer = setTimeout(()=>{
    el.classList.remove('show','hit','miss','speed','mega');
    el.style.display = 'none';
  }, (opts.durationMs != null ? opts.durationMs : (kind === "hit" ? 2600 : 3200)) );
}

function resetSpeedState(){
  comboStreak = 0;
  speedLevel = 0;
  speedBoosted = false;
  practiceBoostCount = 0;
  scaleSeqCount = 0;
  scaleSpeedBoosted = false;
  currentScrollSpeed = baseScrollSpeed;
  if(gameState === 'PLAY' && !waitHold){
    scrollSpeed = currentScrollSpeed;
  }
}
function applySpeed(){
  currentScrollSpeed = baseScrollSpeed + (speedLevel * SPEED_STEP);
  if(gameState === 'PLAY' && !waitHold){
    scrollSpeed = currentScrollSpeed;
  }
}


// „Éá„Éº„Çø
const NUT_X = STAGE.NUT_X;
const STRING_COLORS = ['#ff5757', '#ffde59', '#7ed957', '#5ce1e6'];
const CHORD_LIB = {
  'C':  { name: 'C',  targetIdx: 0, fingers: [{s: 1, f: 3, txt: 'Ëñ¨'}] },
  'F':  { name: 'F',  targetIdx: 0, fingers: [{s: 2, f: 1, txt: '‰∫∫'}, {s: 4, f: 2, txt: '‰∏≠'}] },
  'G7': { name: 'G7', targetIdx: 0, fingers: [{s: 2, f: 1, txt: '‰∫∫'}, {s: 1, f: 2, txt: '‰∏≠'}, {s: 3, f: 2, txt: 'Ëñ¨'}] },
  'Am': { name: 'Am', targetIdx: 0, fingers: [{s: 3, f: 2, txt: '‰∏≠'}] },
  'G':  { name: 'G',  targetIdx: 0, fingers: [{s: 3, f: 2, txt: '‰∫∫'}, {s: 2, f: 3, txt: 'Ëñ¨'}, {s: 1, f: 2, txt: '‰∏≠'}] },
  'A7': { name: 'A7', targetIdx: 0, fingers: [{s: 3, f: 1, txt: '‰∫∫'}] },
  'Dm': { name: 'Dm', targetIdx: 0, fingers: [{s: 4, f: 2, txt: '‰∏≠'}, {s: 3, f: 1, txt: '‰∫∫'}, {s: 2, f: 1, txt: '‰∫∫'}] },
  'Em': { name: 'Em', targetIdx: 0, fingers: [{s: 3, f: 4, txt: 'Â∞è'}, {s: 2, f: 3, txt: 'Ëñ¨'}, {s: 1, f: 2, txt: '‰∏≠'}] },
  'D7': { name: 'D7', targetIdx: 0, fingers: [{s: 2, f: 2, txt: '‰∏≠'}, {s: 3, f: 2, txt: 'Ëñ¨'}, {s: 4, f: 2, txt: '‰∫∫'}] }
};
const SOLO_LIB = {
  'do':  { name:'„Éâ', targetIdx:0, fingers:[{s:3,f:0,txt:'0'}]},
  're':  { name:'„É¨', targetIdx:0, fingers:[{s:3,f:2,txt:'‰∏≠'}]},
  'mi':  { name:'„Éü', targetIdx:0, fingers:[{s:2,f:0,txt:'0'}]},
  'fa':  { name:'„Éï„Ç°', targetIdx:0, fingers:[{s:2,f:1,txt:'‰∫∫'}]},
  'so':  { name:'„ÇΩ', targetIdx:0, fingers:[{s:2,f:3,txt:'Ëñ¨'}]},
  'la':  { name:'„É©', targetIdx:0, fingers:[{s:1,f:0,txt:'0'}]},
  'si':  { name:'„Ç∑', targetIdx:0, fingers:[{s:1,f:2,txt:'‰∏≠'}]},
  'do2': { name:'„Éâ', targetIdx:0, fingers:[{s:1,f:3,txt:'Ëñ¨'}]}
};
const CHORD_SHAPES_AECG = {
  'C':  { name:'C',  frets:{A:3,E:0,C:0,G:0}, fingers:{A:'Ëñ¨',E:'',C:'',G:''} },
  'F':  { name:'F',  frets:{A:0,E:1,C:0,G:2}, fingers:{A:'',E:'‰∫∫',C:'',G:'‰∏≠'} },
  'G7': { name:'G7', frets:{A:2,E:1,C:2,G:0}, fingers:{A:'Ëñ¨',E:'‰∫∫',C:'‰∏≠',G:''} },
};

function chordToTextAEGC(ch){
  const s = CHORD_SHAPES_AECG[ch];
  if(!s) return '';
  const fmt = (f, finger) => (f===0 ? '0' : `${f}${finger||''}`);
  const L = [
    `[${s.name}]`,
    `A: ${fmt(s.frets.A, s.fingers.A)}`,
    `E: ${fmt(s.frets.E, s.fingers.E)}`,
    `C: ${fmt(s.frets.C, s.fingers.C)}`,
    `G: ${fmt(s.frets.G, s.fingers.G)}`,
  ];
  return L.join('\n');
}

function chordObjForPick(chordName, pick){
  const shape = CHORD_SHAPES_AECG[chordName];
  const sidx = {A:1, E:2, C:3, G:4};
  const fingers = [];
  if(!pick) pick = {};
  for(const k of ['A','E','C','G']){
    if(pick[k] === undefined) continue; 
    const f = pick[k];
    if(f === 0){
      fingers.push({s: sidx[k], f: 0, txt: '0'});
    }else{
      const ft = (shape && shape.fingers && shape.fingers[k]) ? shape.fingers[k] : '';
      fingers.push({s: sidx[k], f: f, txt: ft || String(f)});
    }
  }
    let nm = chordName;
  if (fingers.length === 1) {
    try { nm = noteNameForFinger({s: fingers[0].s, f: fingers[0].f}); } catch(e) { nm = chordName; }
  }
  return { name: nm, targetIdx: 0, fingers };
}


function _pcToSolfege(pc){
  const map = {0:"„Éâ",2:"„É¨",4:"„Éü",5:"„Éï„Ç°",7:"„ÇΩ",9:"„É©",11:"„Ç∑",
               1:"„Éâ#",3:"„É¨#",6:"„Éï„Ç°#",8:"„ÇΩ#",10:"„É©#"};
  return map[pc%12] || "?";
}
function noteNameForFinger(fg){
  const basePCByS = {1:9, 2:4, 3:0, 4:7}; 
  const base = basePCByS[fg.s] ?? 0;
  const pc = (base + (fg.f|0)) % 12;
  return _pcToSolfege(pc);
}

const KIRAKIRA_TAB_BLOCKS = [
  { label:"C‚ÜíF‚ÜíC",  A:"--3-----------0--0--3----", E:"--0-----------1-----0----", C:"--0--0--------0-----0----", G:"--0-----0--0--2-----0----" },
  { label:"G7‚ÜíC‚ÜíG7‚ÜíC", A:"--2-----3-----2-----3----", E:"--1--1--0--0--1-----0----", C:"--2-----0-----2--2--0----", G:"--0-----0-----0-----0----" },
  { label:"C‚ÜíG7‚ÜíC‚ÜíG7", A:"--3-----2-----3-----2----", E:"--0-----1--1--0--0--1----", C:"--0-----2-----0-----2----", G:"--0--0--0-----0-----0----" },
  { label:"G7‚ÜíC‚ÜíG7‚ÜíC", A:"--2-----3-----2-----3----", E:"--1--1--0--0--1-----0----", C:"--2-----0-----2--2--0----", G:"--0-----0-----0-----0----" },
  { label:"C‚ÜíF‚ÜíC",  A:"--3-----------0--0--3----", E:"--0-----------1-----0----", C:"--0--0--------0-----0----", G:"--0-----0--0--2-----0----" },
  { label:"G7‚ÜíC‚ÜíG7‚ÜíC", A:"--2-----3-----2-----3----", E:"--1--1--0--0--1-----0----", C:"--2-----0-----2--2--0----", G:"--0-----0-----0-----0----" },
  { label:"C",         A:"--3----------------------", E:"--0----------------------", C:"--0----------------------", G:"--0----------------------" },
];

function _tabEventCols(block){
  const L = block.A.length;
  const cols = [];
  for(let i=0;i<L;i++){
    const a=block.A[i], e=block.E[i], c=block.C[i], g=block.G[i];
    if((a>='0'&&a<='9') || (e>='0'&&e<='9') || (c>='0'&&c<='9') || (g>='0'&&g<='9')){
      cols.push(i);
    }
  }
  return cols;
}
function _tabNotesAt(block, col){
  const out = {};
  const a=block.A[col], e=block.E[col], c=block.C[col], g=block.G[col];
  if(a>='0'&&a<='9') out.A = parseInt(a,10);
  if(e>='0'&&e<='9') out.E = parseInt(e,10);
  if(c>='0'&&c<='9') out.C = parseInt(c,10);
  if(g>='0'&&g<='9') out.G = parseInt(g,10);
  return out;
}
function _detectChordFromNotes(notes){
  const hasA = (notes.A!==undefined), hasE=(notes.E!==undefined), hasC=(notes.C!==undefined), hasG=(notes.G!==undefined);
  const count = (hasA?1:0)+(hasE?1:0)+(hasC?1:0)+(hasG?1:0);
  if(count < 3) return null;
  if((notes.A===3) && (notes.E===0) && (notes.C===0) && (notes.G===0)) return 'C';
  if((notes.A===0) && (notes.E===1) && (notes.C===0) && (notes.G===2)) return 'F';
  if((notes.A===2) && (notes.E===1) && (notes.C===2)) return 'G7';
  return null;
}
function _pickText(notes){
  const parts = [];
  if(notes.A!==undefined) parts.push(`1A${notes.A}`);
  if(notes.E!==undefined) parts.push(`2E${notes.E}`);
  if(notes.C!==undefined) parts.push(`3C${notes.C}`);
  if(notes.G!==undefined) parts.push(`4G${notes.G}`);
  return parts.length ? parts.join(' ') : '-';
}

function buildKirakiraFromTabBlocks(blocks){
  const out = [];
  let currentChord = 'C'; 
  for(const block of blocks){
    const cols = _tabEventCols(block);
    const steps = [];
    for(let i=0;i<8;i++){
      if(i < cols.length){
        const notes = _tabNotesAt(block, cols[i]);
        const det = _detectChordFromNotes(notes);
        if(det) currentChord = det;
        steps.push({ chord: currentChord, pick: notes });
      }else{
        steps.push({ chord: currentChord, pick: {} });
      }
    }
    for(const st of steps){
      out.push({ chord: chordObjForPick(st.chord, st.pick), lyrics: '' });
    }
  }
  return out;
}

const SONG_DATA = buildKirakiraFromTabBlocks(KIRAKIRA_TAB_BLOCKS);




let songIndex=0; let practiceIndex=0; let scaleIndex=0;
let songFinished=false; let songFinishedAt=0;
let currentLevelChords = [];
let spawnInterval = 2800; 
let lastStartParams = null; 

// --- UIÊìç‰Ωú ---
let entryKind = 'uke'; // 'tap' or 'uke'
let uiMode = 'WAIT';   // 'NORMAL' or 'WAIT'

function isTapMode(){
  return String(playMode||'').toUpperCase().startsWith('TAP');
}
function isWaitMode(){
  return (playMode === 'WAIT' || playMode === 'TAP_WAIT');
}

function toggleSoundSource(type){
  if(type === 'sample' && !window.hasRecordedSamples){
    alert("„Åæ„Å†Èå≤Èü≥„Åï„Çå„ÅüÈü≥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„ÉÅ„É•„Éº„Éã„É≥„Ç∞ÈñãÂßãÂæå„Å´„ÄåÈå≤Èü≥„Åô„Çã„Äç„ÇíÈÅ∏„Å∂„Å®‰Ωú„Çå„Åæ„Åô„ÄÇ");
    return;
  }
  useSampledSound = (type === 'sample');
  document.getElementById('btn-sound-synth').classList.toggle('active', !useSampledSound);
  document.getElementById('btn-sound-sample').classList.toggle('active', useSampledSound);
}

function applyUiMode(mode){
  uiMode = (String(mode||'').toUpperCase() === 'NORMAL') ? 'NORMAL' : 'WAIT';
  if(entryKind === 'tap'){
    playMode = (uiMode === 'NORMAL') ? 'TAP_NORMAL' : 'TAP_WAIT';
  }else{
    playMode = uiMode; 
  }

  document.querySelectorAll('.mode-pill[data-mode]').forEach(b => {
    const m = (b.getAttribute('data-mode')||'').toUpperCase();
    b.classList.toggle('active', m === uiMode);
  });

  const desc = document.getElementById('mode-desc');
  if(desc){
    desc.textContent = (uiMode === 'NORMAL')
      ? '„Éé„Éº„Éû„É´Ôºö„Å™„Åå„Çå„Å¶„Åè„Çã„ÇàÔºà„Åµ„Å§„ÅÜÔºâ'
      : '„Çµ„Éù„Éº„Éà‰ªò„ÅçÔºö„Å®„Åæ„Å£„Å¶ „Åæ„Å§„ÇàÔºà„ÅØ„Åò„ÇÅ„Å¶„Å´„Åä„Åô„Åô„ÇÅÔºâ';
  }

  const tapWrap = document.getElementById('tap-vol-wrap');
  const soundWrap = document.getElementById('sound-toggle-wrap');
  
  if(entryKind === 'tap'){
     if(tapWrap) tapWrap.style.display = 'block';
     if(soundWrap) soundWrap.style.display = 'none';
  } else {
     if(tapWrap) tapWrap.style.display = 'none';
     if(soundWrap) soundWrap.style.display = 'flex';
  }

  const mt = document.getElementById('menuTitle');
  if(mt){
    mt.textContent = (entryKind === 'tap') ? 'üëÜ „Çø„ÉÉ„Éó„Åß„ÅÇ„Åù„Å∂' : 'ü™ï „Ç¶„ÇØ„É¨„É¨„Åß„ÅÇ„Åù„Å∂';
  }
  
  // body classes for CSS handling
  document.body.classList.toggle('is-tap', entryKind === 'tap');
  document.body.classList.toggle('is-uke', entryKind !== 'tap');

  const backBtn = document.getElementById('menuBackBtn');
  if(backBtn){
    backBtn.textContent = (entryKind === 'tap') ? 'üèùÔ∏è TOP„Å∏„ÇÇ„Å©„Çã' : 'ü™ï „Ç¶„ÇØ„É¨„É¨„Å∏„ÇÇ„Å©„Çã';
  }
}

function setMode(el, mode){
  applyUiMode(mode);
}

(function applyModeFromQuery(){
  try{
    const p = new URLSearchParams(location.search);
    const m = (p.get('mode')||'').toUpperCase();

    if(m === 'TAP'){
      entryKind = 'tap';
      applyUiMode('WAIT'); 
      return;
    }
    if(m === 'NORMAL' || m === 'WAIT'){
      entryKind = 'uke';
      applyUiMode(m);
      return;
    }

    entryKind = 'uke';
    applyUiMode('WAIT');
  }catch(e){
    entryKind = 'uke';
    applyUiMode('WAIT');
  }
})(); 

function goBackFromGameMenu(){
  const url = (entryKind === 'tap') ? 'index.html' : 'ukulele.html';
  goFlip(url);
}

function goMenu(){
  try{ window.stopTapPreview && window.stopTapPreview(); }catch(e){}
  try{ document.body.classList.remove('playing'); document.body.classList.add('menuOpen'); }catch(e){}
  if(rafId) cancelAnimationFrame(rafId);
  gameState = 'MENU';
  try{ document.body.classList.add('isMenu'); }catch(e){}
  
  document.getElementById('menu-overlay').style.display = 'flex';
  document.getElementById('score-panel').style.display = 'none';
  document.getElementById('timer-panel').style.display = 'none';
  document.getElementById('stopBtn').style.display = 'none';
  document.getElementById('pause-overlay').style.display = 'none';
  document.getElementById('result-overlay').style.display = 'none';
  document.getElementById('back-btn').style.display = 'none';
  document.getElementById('chordHud').style.display = 'none';
  document.getElementById('lyrics-area').innerText = '';
  document.getElementById('sampler-overlay').style.display = 'none';
  
  ctx.clearRect(0,0,canvas.width,canvas.height);
  resetSpeedState();
  const fx=document.getElementById('fxMsg'); if(fx){ fx.style.display='none'; fx.className=''; }
}

document.getElementById('stopBtn').onclick = () => {
  if(gameState==='PLAY') {
    gameState='PAUSE';
    document.getElementById('pause-overlay').style.display='flex';
  }
};
function resumeGame(){
  gameState='PLAY';
  try{ document.body.classList.remove('isMenu'); }catch(e){}
  document.getElementById('pause-overlay').style.display='none';
  lastFrameT=0; rafId=requestAnimationFrame(gameLoop);
}

// --- „Ç≤„Éº„É†ÈñãÂßã„Éï„É≠„Éº ---
async function prepGame(type){
  try{ window.stopTapPreview && window.stopTapPreview(); }catch(e){}
  lastStartParams = type;

  // „Çø„ÉÉ„Éó„É¢„Éº„Éâ„Å™„ÇâÂç≥ÈñãÂßã
  if(isTapMode()){ 
      try{
        ensureTapAudio();
        const v = getTapVolume01();
        if(v < 0.1 || (tapAudioCtx && tapAudioCtx.state === 'suspended')){
            if(tapAudioCtx && tapAudioCtx.state === 'suspended') tapAudioCtx.resume();
            showFx('üéµ Èü≥Èáè„ÇíON„Å´„Åó„Å¶„Å≠\n„Éû„Éä„Éº„É¢„Éº„Éâ„ÇÇËß£Èô§„Åó„Å¶„Å≠', 'speed', { durationMs: 4000 });
        }
      }catch(e){}
      startGameByType(type); 
      return; 
  }

  // „Éû„Ç§„ÇØÊ∫ñÂÇô & „ÉÅ„É•„Éº„Éã„É≥„Ç∞„Éï„É≠„Éº
  document.getElementById('loading-overlay').style.display = 'flex';
  try {
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if(audioCtx.state === 'suspended') await audioCtx.resume();

    if(!micStream){
      micStream = await navigator.mediaDevices.getUserMedia({
        audio: IS_IOS ? { echoCancellation:false, noiseSuppression:false, autoGainControl:false } : true
      });
      const src = audioCtx.createMediaStreamSource(micStream);
      micAnalyser = audioCtx.createAnalyser();
      const gain = audioCtx.createGain();
      gain.gain.value = IS_IOS ? 3.9 : 1.0;
      micAnalyser.fftSize = IS_IOS ? 4096 : 2048;
      src.connect(gain).connect(micAnalyser);
    }
    
    // Output Audio
    ensureTapAudio();

    const stored = loadGameThresholds();
    await new Promise(r => setTimeout(r, 200)); 
    NOISE_RMS = await measureNoiseRms(950, 95);
    applyThresholdsFrom(NOISE_RMS, stored);

    document.getElementById('loading-overlay').style.display = 'none';

    // ‚òÖ„ÉÅ„É•„Éº„Éã„É≥„Ç∞/„Çµ„É≥„Éó„É™„É≥„Ç∞„ÅÆ„Ç™„Éº„Éê„Éº„É¨„Ç§„ÇíË°®Á§∫
    showTuningOverlay();

  } catch(e) {
    console.error(e);
    alert('„Éû„Ç§„ÇØ„Åå‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ„Çø„ÉÉ„Éó„É¢„Éº„Éâ„ÅßÈñãÂßã„Åó„Åæ„Åô„ÄÇ');
    entryKind = 'tap'; applyUiMode('WAIT');
    document.getElementById('loading-overlay').style.display = 'none';
    startGameByType(type);
  }
}

// --- SAMPLER LOGIC ---
// ÁõÆÁöÑÔºö
// - „Äå„ÉÅ„É•„Éº„Éã„É≥„Ç∞ÈñãÂßã„ÄçÂæå„Å´„ÄåÈå≤Èü≥„Åô„ÇãÔºü„Åó„Å™„ÅÑÔºü„Äç„ÇíËÅû„Åè
// - „ÉÅ„É•„Éº„Éã„É≥„Ç∞„ÅßOK„Å´„Å™„Å£„ÅüÈü≥Ôºà1„Äú4Âº¶Ôºâ„Çí„ÄÅ„Åù„ÅÆÂ†¥„Åß„Çµ„É≥„Éó„É™„É≥„Ç∞
// - „Çµ„É≥„Éó„É™„É≥„Ç∞Âæå„Å´„ÄåOK / „ÇÑ„ÇäÁõ¥„Åô / „ÇÑ„Å£„Å±„ÇÑ„ÇÅ„Çã„Äç„Çí„ÄÅË®∫Êñ≠Ë°®Á§∫„Çà„ÇäÂÖà„Å´ËÅû„Åè
let samplerState = 'idle';
let samplerDoRecord = false;
let currentSampleStringIdx = 0; // 0=A, 1=E, 2=C, 3=G
let tuningOk = [false, false, false, false];

const TARGET_FREQS = [440.00, 329.63, 261.63, 392.00]; // A, E, C, G
const TARGET_NAMES = ['1Âº¶ (A)', '2Âº¶ (E)', '3Âº¶ (C)', '4Âº¶ (G)'];

window.customSamples = [null, null, null, null];
window.hasRecordedSamples = false;

// UI helpers
function updateSamplerUI(title, msg, isHtml){
  document.getElementById('samplerTitle').innerText = title;
  if(isHtml){
    document.getElementById('samplerMsg').innerHTML = msg;
  }else{
    document.getElementById('samplerMsg').innerText = msg;
  }
}
function setSamplerBtns(html){
  const el = document.getElementById('samplerBtns');
  el.innerHTML = html;
  el.style.display = 'flex';
}
function hideSamplerBtns(){ document.getElementById('samplerBtns').style.display = 'none'; }
function showMeter(on){
  document.getElementById('samplerMeterBox').style.display = on ? 'block' : 'none';
}
function renderProgress(){
  return TARGET_NAMES.map((n,i)=> (tuningOk[i] ? `‚úÖ ${n}` : `‚¨ú ${n}`)).join('<br>');
}

// Pitch detect (simple autocorrelation)
function autoCorrelate(buf, sampleRate) {
  let SIZE = buf.length;
  let rms = 0;
  for (let i=0;i<SIZE;i++) { let val = buf[i]; rms += val*val; }
  rms = Math.sqrt(rms/SIZE);
  if (rms<0.01) return -1;

  let r1=0, r2=SIZE-1, thres=0.2;
  for (let i=0; i<SIZE/2; i++) if (Math.abs(buf[i])<thres) { r1=i; break; }
  for (let i=1; i<SIZE/2; i++) if (Math.abs(buf[SIZE-i])<thres) { r2=SIZE-i; break; }
  buf = buf.slice(r1,r2);
  SIZE = buf.length;

  let c = new Array(SIZE).fill(0);
  for (let i=0; i<SIZE; i++) {
    for (let j=0; j<SIZE-i; j++) c[i] = c[i] + buf[j]*buf[j+i];
  }
  let d=0; while (c[d]>c[d+1]) d++;
  let maxval=-1, maxpos=-1;
  for (let i=d; i<SIZE; i++) {
    if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
  }
  let T0 = maxpos;
  if(!T0 || T0 <= 0) return -1;
  return sampleRate/T0;
}

function showTuningOverlay(){
  const ov = document.getElementById('sampler-overlay');
  ov.style.display = 'flex';
  showMeter(false);
  samplerState = 'idle';

  updateSamplerUI(
    "„ÉÅ„É•„Éº„Éã„É≥„Ç∞",
    "„Ç¶„ÇØ„É¨„É¨„ÅÆÊ∫ñÂÇô„ÅØ„ÅÑ„ÅÑ„Åß„Åô„ÅãÔºü<br>1Âº¶„Åã„ÇâÈ†ÜÁï™„Å´Èü≥„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Åæ„Åô„ÄÇ",
    true
  );

  setSamplerBtns(`
    <button class="action-btn btn-secondary" onclick="skipSampling()">„Çπ„Ç≠„ÉÉ„ÉóÔºà„ÉÅ„É•„Éº„Éã„É≥„Ç∞„Åó„Å™„ÅÑÔºâ</button>
    <button class="action-btn btn-primary" onclick="startTuningFlow()">„ÉÅ„É•„Éº„Éã„É≥„Ç∞ÈñãÂßãÔºÅ</button>
  `);
}

function skipSampling(){
  samplerState = 'idle';
  document.getElementById('sampler-overlay').style.display = 'none';
  startGameByType(lastStartParams);
}

function startTuningFlow(){
  // „ÉÅ„É•„Éº„Éã„É≥„Ç∞ÈñãÂßãÂæå„Å´„ÄåÈå≤Èü≥„Åô„ÇãÔºü„Äç„ÇíËÅû„Åè
  samplerState = 'choose_record';
  tuningOk = [false, false, false, false];
  currentSampleStringIdx = 0;
  showMeter(false);

  updateSamplerUI(
    "„ÉÅ„É•„Éº„Éã„É≥„Ç∞",
    "„Åì„ÅÆ„ÅÇ„Å®„ÄÅÂêÑÂº¶„ÇíÂºæ„ÅÑ„Å¶OK„ÇíÂá∫„Åó„Åæ„Åô„ÄÇ<br><b>OK„Å´„Å™„Å£„ÅüÈü≥„ÇíÈå≤Èü≥Ôºà„Çµ„É≥„Éó„É™„É≥„Ç∞Ôºâ„Åó„Åæ„Åô„ÅãÔºü</b>",
    true
  );

  setSamplerBtns(`
    <button class="action-btn btn-primary" onclick="beginTuning(true)">Èå≤Èü≥„Åô„Çã</button>
    <button class="action-btn btn-secondary" onclick="beginTuning(false)">Èå≤Èü≥„Åó„Å™„ÅÑ</button>
    <button class="action-btn btn-secondary" onclick="skipSampling()" style="font-size:12px; padding:10px;">„ÇÑ„ÇÅ„Çã</button>
  `);
}

// candidate recording (to capture attack) when samplerDoRecord=true
let __cand = null; // {rec, chunks, done, stopTimer, startedAt, mime}
const REC_MS = 2600;
const MATCH_TIMEOUT_MS = 750;

function chooseRecorderMime(){
  try{
    if(window.MediaRecorder && MediaRecorder.isTypeSupported){
      if(MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) return 'audio/webm;codecs=opus';
      if(MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) return 'audio/ogg;codecs=opus';
      if(MediaRecorder.isTypeSupported('audio/mp4')) return 'audio/mp4';
    }
  }catch(e){}
  return '';
}

function normalizeAndFadeBuffer(buf){
  try{
    if(!buf) return buf;
    const chs = buf.numberOfChannels || 1;
    let peak = 0;
    for(let ch=0; ch<chs; ch++){
      const data = buf.getChannelData(ch);
      for(let i=0; i<data.length; i++){
        const a = Math.abs(data[i]);
        if(a > peak) peak = a;
      }
    }
    const target = 0.88;
    const g = (peak > 0.001) ? Math.min(1.0, target / peak) : 1.0;

    const fadeIn = Math.floor(buf.sampleRate * 0.006);
    const fadeOut = Math.floor(buf.sampleRate * 0.085);

    for(let ch=0; ch<chs; ch++){
      const data = buf.getChannelData(ch);

      if(g !== 1.0){
        for(let i=0;i<data.length;i++) data[i] *= g;
      }

      // fade in
      for(let i=0;i<fadeIn && i<data.length;i++){
        data[i] *= (i / Math.max(1, fadeIn));
      }
      // fade out
      for(let i=0;i<fadeOut && i<data.length;i++){
        const idx = data.length - 1 - i;
        const k = (i / Math.max(1, fadeOut));
        data[idx] *= (1 - k);
      }
    }
  }catch(e){}
  return buf;
}

function startCandidateRecording(){
  return new Promise((resolve)=>{
    try{
      if(!window.MediaRecorder || !micStream){
        resolve(null); return;
      }
      const mime = chooseRecorderMime();
      let rec = null;
      try{
        rec = mime ? new MediaRecorder(micStream, { mimeType: mime }) : new MediaRecorder(micStream);
      }catch(e){
        rec = new MediaRecorder(micStream);
      }
      const chunks = [];
      let doneResolve;
      const done = new Promise(r=>doneResolve=r);

      rec.ondataavailable = (e)=>{ if(e && e.data && e.data.size) chunks.push(e.data); };
      rec.onstop = ()=>{ doneResolve({chunks, mime: (rec.mimeType || mime || '')}); };

      rec.start();
      const startedAt = performance.now ? performance.now() : Date.now();
      const stopTimer = setTimeout(()=>{ try{ rec.stop(); }catch(e){} }, REC_MS);

      resolve({rec, chunks, done, stopTimer, startedAt, mime: (rec.mimeType || mime || '')});
    }catch(err){
      resolve(null);
    }
  });
}

async function finalizeCandidateToSample(cand, idx){
  if(!cand) return;
  try{
    const info = await cand.done;
    clearTimeout(cand.stopTimer);

    const blob = new Blob(info.chunks, { type: info.mime || 'audio/webm' });
    const arrayBuffer = await blob.arrayBuffer();

    const audioBuffer = await tapAudioCtx.decodeAudioData(arrayBuffer);
    window.customSamples[idx] = normalizeAndFadeBuffer(audioBuffer);
  }catch(e){
    console.error(e);
  }
}

async function discardCandidate(cand){
  if(!cand) return;
  try{
    clearTimeout(cand.stopTimer);
    if(cand.rec && cand.rec.state !== 'inactive'){
      cand.rec.stop();
    }
  }catch(e){}
}

async function beginTuning(doRecord){
  samplerDoRecord = !!doRecord;
  try{ ensureTapAudio(); }catch(e){}
  samplerState = 'wait_quiet';
  currentSampleStringIdx = 0;
  __cand = null;

  // ‰ªäÂõû„ÅØ„Åì„ÅÆ„ÉÅ„É•„Éº„Éã„É≥„Ç∞„ÅßÈå≤Èü≥„Åó„Åü„ÇÇ„ÅÆ„Å†„Åë„ÇíÊé°Áî®Ôºà„ÇÑ„ÇÅ„Åü„ÇâÁ†¥Ê£ÑÔºâ
  window.customSamples = [null, null, null, null];
  window.hasRecordedSamples = false;

  showMeter(true);
  hideSamplerBtns();

  updateSamplerUI(
    "„Åó„Åö„Åã„Å´„Åó„Å¶„Å≠...",
    "„Åæ„Çè„Çä„ÅÆ „Åä„Å®„Çí „Åó„Çâ„Åπ„Å¶„ÅÑ„Åæ„Åô",
    false
  );

  await samplerLoop();
}

function askForString(idx){
  const recMsg = samplerDoRecord ? "ÔºàOK„Å´„Å™„Å£„ÅüÁû¨Èñì„Å´„ÄÅ„Åù„ÅÆÈü≥„ÇíÈå≤Èü≥„Åó„Åæ„ÅôÔºâ" : "ÔºàOK„Å†„ÅëÂá∫„Åó„Åæ„ÅôÔºâ";
  updateSamplerUI(
    `„ÉÅ„É•„Éº„Éã„É≥„Ç∞: ${TARGET_NAMES[idx]}`,
    `${renderProgress()}<br><br><b>${TARGET_NAMES[idx]}</b> „Çí „Éù„Éº„É≥ „Å®Âºæ„ÅÑ„Å¶„Å≠ÔºÅ<br>${recMsg}`,
    true
  );
}

async function samplerLoop(){
  // overlay„ÅåÈñâ„Åò„Åü„ÇâÂÅúÊ≠¢
  if(document.getElementById('sampler-overlay').style.display === 'none') return;

  // safety
  if(!micAnalyser){
    samplerState = 'done';
    setSamplerBtns(`<button class="action-btn btn-primary" onclick="skipSampling()">„Å§„Å•„Åë„Çã</button>`);
    return;
  }

  const buf = new Float32Array(micAnalyser.fftSize);
  micAnalyser.getFloatTimeDomainData(buf);

  // Meter
  let sum=0; for(let i=0;i<buf.length;i++) sum+=buf[i]*buf[i];
  let rms = Math.sqrt(sum/buf.length);
  document.getElementById('samplerBar').style.width = Math.min(100, rms*500) + '%';

  const nowMs = (performance.now ? performance.now() : Date.now());

  if(samplerState === 'wait_quiet'){
    // Èùô„Åë„Åï„ÅåÂ∞ë„ÅóÁ∂ö„ÅÑ„Åü„ÇâÊ¨°„Å∏
    if(!samplerLoop.__quietSince) samplerLoop.__quietSince = null;
    if(rms < 0.05){
      if(samplerLoop.__quietSince == null) samplerLoop.__quietSince = nowMs;
      if(nowMs - samplerLoop.__quietSince > 450){
        samplerLoop.__quietSince = null;
        samplerState = 'listen';
        askForString(currentSampleStringIdx);
      }
    }else{
      samplerLoop.__quietSince = null;
    }
  }
  else if(samplerState === 'listen'){
    const target = TARGET_FREQS[currentSampleStringIdx];

    // Èü≥„ÅåÈ≥¥„Å£„Åü„ÇâÔºàattackÔºâÂÖà„Å´Èå≤Èü≥„ÇíÈñãÂßã„Åó„Å¶ÊîªÊíÉÈü≥„ÇíÂèñ„Çä„Åì„Åº„Åï„Å™„ÅÑ
    if(samplerDoRecord && !__cand && rms > 0.06){
      __cand = await startCandidateRecording();
      if(__cand){
        updateSamplerUI(`„ÉÅ„É•„Éº„Éã„É≥„Ç∞: ${TARGET_NAMES[currentSampleStringIdx]}`, `${renderProgress()}<br><br>Èå≤Èü≥‰∏≠...Ôºà‰ΩôÈüª„Åæ„ÅßÔºâ`, true);
      }
    }

    const pitch = autoCorrelate(buf, audioCtx.sampleRate);
    if(rms > 0.05 && pitch > 0){
      const ratio = pitch / target;
      if(ratio > 0.86 && ratio < 1.14){
        // OK!
        tuningOk[currentSampleStringIdx] = true;

        if(samplerDoRecord && __cand){
          samplerState = 'capturing';
          updateSamplerUI("Èå≤Èü≥‰∏≠...", "„Åù„ÅÆ„Åæ„Åæ Èü≥„Çí„ÅÆ„Å∞„Åó„Å¶„Å≠", false);

          await finalizeCandidateToSample(__cand, currentSampleStringIdx);
          __cand = null;
        }else{
          // Èå≤Èü≥„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÂ∞ë„ÅóÂæÖ„Å£„Å¶Ê¨°„Å∏
          __cand = null;
        }

        currentSampleStringIdx++;

        if(currentSampleStringIdx >= 4){
          if(samplerDoRecord){
            samplerState = 'verify';
            verifySamples();
            return;
          }else{
            samplerState = 'done_tuning';
            showTuningDone();
            return;
          }
        }else{
          samplerState = 'wait_quiet';
        }
      }
    }

    // Èå≤Èü≥ÈñãÂßã„Åó„Åü„Åå„ÄÅÂêà„Å£„Å¶„ÅÑ„Å™„ÅÑ„Åæ„Åæ‰∏ÄÂÆöÊôÇÈñìÁµåÈÅé ‚Üí Á†¥Ê£Ñ„Åó„Å¶„ÇÑ„ÇäÁõ¥„Åó
    if(__cand){
      const elapsed = nowMs - __cand.startedAt;
      if(elapsed > MATCH_TIMEOUT_MS && !tuningOk[currentSampleStringIdx]){
        await discardCandidate(__cand);
        __cand = null;
        updateSamplerUI(`„ÉÅ„É•„Éº„Éã„É≥„Ç∞: ${TARGET_NAMES[currentSampleStringIdx]}`, `${renderProgress()}<br><br>„Å°„Çá„Å£„Å® „Å°„Åå„ÅÜ„Åø„Åü„ÅÑ‚Ä¶ „ÇÇ„ÅÜ„ÅÑ„Å°„Å©ÔºÅ`, true);
        samplerState = 'wait_quiet';
      }
    }
  }
  else if(samplerState === 'capturing'){
    // finalizeCandidateToSample „ÅåÁµÇ„Çè„Çã„Åæ„ÅßÂæÖ„Å§Ôºà„Åì„Åì„Å´„ÅØÈÄöÂ∏∏Êù•„Å™„ÅÑÔºâ
  }

  if(samplerState !== 'verify' && samplerState !== 'done_tuning' && samplerState !== 'done'){
    requestAnimationFrame(samplerLoop);
  }
}

function verifySamples(){
  updateSamplerUI("Èå≤Èü≥„Åß„Åç„Åü„ÇàÔºÅ", "Èå≤Èü≥„Åó„ÅüÈü≥„Çí „Åç„ÅÑ„Å¶„Åø„Å¶„Å≠", false);
  showMeter(false);

  // Playback Arpeggio (4->3->2->1)
  [3, 2, 1, 0].forEach((sIdx, i) => {
    setTimeout(()=>{ playSampleBuffer(sIdx, 1.0); }, i * 520);
  });

  setTimeout(()=>{
    setSamplerBtns(`
      <div style="display:flex; flex-direction:column; gap:8px; width:100%;">
        <button class="action-btn btn-primary" onclick="finishSampling(true)">OKÔºà„Åì„ÅÆÈü≥„Åß„ÅÇ„Åù„Å∂Ôºâ</button>
        <button class="action-btn btn-secondary" onclick="startTuningFlow()">„ÇÑ„ÇäÁõ¥„ÅôÔºà„ÇÇ„ÅÜ‰∏ÄÂ∫¶Èå≤Èü≥Ôºâ</button>
        <button class="action-btn btn-secondary" onclick="finishSampling(false)" style="font-size:12px; padding:10px;">„ÇÑ„Å£„Å±„ÇÑ„ÇÅ„ÇãÔºà„ÅÑ„Å§„ÇÇ„ÅÆÈü≥Ôºâ</button>
      </div>
    `);
  }, 2500);
}

function playSampleBuffer(stringIdx, rate){
  if(!window.customSamples[stringIdx]) return;
  try{ ensureTapAudio(); }catch(e){}
  try{ ensureHitBus(); }catch(e){}

  const src = tapAudioCtx.createBufferSource();
  src.buffer = window.customSamples[stringIdx];
  src.playbackRate.value = rate;

  const gain = tapAudioCtx.createGain();
  gain.gain.value = 0.55;

  // Fade Out (preview)
  const now = tapAudioCtx.currentTime;
  const dur = Math.min(src.buffer.duration / Math.max(0.1, src.playbackRate.value), 2.8);
  const rel = Math.min(0.75, Math.max(0.35, dur * 0.28));
  gain.gain.setValueAtTime(0.55, now);
  gain.gain.setValueAtTime(0.55, Math.max(now, now + dur - rel));
  gain.gain.linearRampToValueAtTime(0, now + dur);

  src.connect(gain).connect(hitIn);
  src.start();
}

function showTuningDone(){
  showMeter(false);
  updateSamplerUI("„ÉÅ„É•„Éº„Éã„É≥„Ç∞OKÔºÅ", "„Åù„ÅÆ„Åæ„Åæ „ÅØ„Åò„ÇÅ„Çà„ÅÜ", false);

  setSamplerBtns(`
    <button class="action-btn btn-primary" onclick="finishSampling(false)">„ÅØ„Åò„ÇÅ„Çã</button>
    <button class="action-btn btn-secondary" onclick="startTuningFlow()">„ÇÑ„ÇäÁõ¥„Åô</button>
  `);
}

function finishSampling(useRecorded){
  const use = !!useRecorded;

  if(use){
    window.hasRecordedSamples = true;
    try{ toggleSoundSource('sample'); }catch(e){}
  }else{
    // „Äå„ÇÑ„Å£„Å±„ÇÑ„ÇÅ„Çã / Èå≤Èü≥„Åó„Å™„ÅÑ„Äç‚ÜíÈå≤Èü≥„Éá„Éº„Çø„ÅØÁ†¥Ê£ÑÔºàÊ¨°Âõû„Åæ„Åü‰ΩúÊàêÔºâ
    window.hasRecordedSamples = false;
    window.customSamples = [null, null, null, null];
    try{ toggleSoundSource('synth'); }catch(e){}
  }

  document.getElementById('sampler-overlay').style.display = 'none';
  startGameByType(lastStartParams);
}


function startGameByType(type){
  lastStartParams = type;
  try{ document.body.classList.add('playing'); document.body.classList.remove('menuOpen'); }catch(e){}
  if(type==='scale') initGame('scale', null, {speedBase:3.4});
  else if(type==='easy') initGame('practice', ['C','F','G7','Am'], {speedBase:3.2});
  else if(type==='hard') initGame('practice', ['C','F','G7','Am','G','A7','Dm','Em','D7'], {speedBase:3.35});
  else if(type==='song') initGame('song', '„Åç„Çâ„Åç„ÇâÊòü', {speedBase:getSongSpeedBase(), disableSpeedUp:true});
}

function restartLast(){
  document.getElementById('result-overlay').style.display='none';
  startGameByType(lastStartParams || 'easy');
}

function initGame(mode, levelData, opts){
  if(rafId) cancelAnimationFrame(rafId);
  gameState='PLAY';
  
  // UI„É™„Çª„ÉÉ„Éà
  document.getElementById('menu-overlay').style.display='none';
  document.getElementById('result-overlay').style.display='none';
  document.getElementById('score-panel').style.display='block';
  document.getElementById('timer-panel').style.display='block';
  document.getElementById('stopBtn').style.display='block';
  document.getElementById('back-btn').style.display='none'; 

  // Â§âÊï∞„É™„Çª„ÉÉ„Éà
  score=0; groups=[]; stars=[];
  waitHold=false; waitTargetGroup=null;
  baseScrollSpeed = (opts.speedBase || 3.5) * BASE_SPEED_MULT;
  currentScrollSpeed = baseScrollSpeed;
  scrollSpeed = currentScrollSpeed;
  resetSpeedState();
  gameMode = mode;
  isSongMode = (mode==='song');
  disableSpeedUpActive = !!(opts.disableSpeedUp); 
  currentLevelChords = levelData || [];
  practiceIndex=0; scaleIndex=0; songIndex=0; songFinished=false; songFinishedAt=0;
  spawnInterval = 2800; 
  if(isSongMode){
    const sid = getSongSpeedId();
    spawnInterval = (sid==='SLOW') ? 1100 : (sid==='FAST') ? 275 : 550; 
  }

  document.getElementById('score').innerText="0";
  document.getElementById('lyrics-area').innerText="";
  if(isSongMode){
    gameEndAt = null;
    document.getElementById('timer-panel').style.display='none';
  }else{
    document.getElementById('timer-panel').style.display='block';
    gameEndAt = performance.now() + 60000;
  }

  // ÊÑüÂ∫¶„É™„Çª„ÉÉ„Éà
  prevRms = NOISE_RMS;
  pluckHoldCount=0; ignorePluckUntil=Date.now()+500;

  rafId = requestAnimationFrame(gameLoop);
}

// --- „É°„Ç§„É≥„É´„Éº„Éó ---
let lastFrameT=0;
function gameLoop(time){
  if(gameState!=='PLAY') return;
  try{
  if(!lastFrameT) lastFrameT=time;
  lastFrameT=time;

  // „Çø„Ç§„Éû„Éº
  if(gameEndAt!=null && !waitHold){
    const rem = Math.max(0, gameEndAt - performance.now());
    document.getElementById('timer').innerText = Math.ceil(rem/1000);
    if(rem<=0) { endGame(); return; }
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawFretboard();

  // „Çπ„Éù„Éº„É≥
  if(!waitHold && (time - lastSpawn > spawnInterval)){
    let cnt=0, maxX=-9999;
    for(let g of groups) { if(g.active){ cnt++; if(g.x>maxX) maxX=g.x; } }
    
    if(cnt<3 && (maxX < canvas.width+120 - 760)){ 
      if(isSongMode){
        if(songIndex < SONG_DATA.length){
          const d = SONG_DATA[songIndex];
          groups.push(new ChordGroup(d.chord ? d.chord : (d.lib[d.key]), d.lyrics));
          songIndex++;
          if(songIndex >= SONG_DATA.length){ songFinished = true; songFinishedAt = performance.now(); }
        } else {
          if(!songFinished){ songFinished = true; songFinishedAt = performance.now(); }
        }

      } else if(gameMode==='scale'){
        const k = ['do','re','mi','fa','so','la','si','do2'][scaleIndex%8];
        const g = new ChordGroup(SOLO_LIB[k], "");
        g.noteKey = k;
        groups.push(g);
        scaleIndex++;
      } else {
        const k = currentLevelChords[practiceIndex % currentLevelChords.length];
        groups.push(new ChordGroup(CHORD_LIB[k], ""));
        practiceIndex++;
      }
      lastSpawn=time;
    }
  }

  // HUD & Draw
  let target=null, bestDist=Infinity;
  for(let g of groups){
    if(!g.active) continue;
    const d = Math.abs(g.x - NUT_X);
    if(d < bestDist && d < 620 + 100){ bestDist=d; target=g; }
  }
  if(target){
    target.isTarget=true;
  } 

  for(let i=groups.length-1; i>=0; i--){
    groups[i].update(); groups[i].draw();
    if(groups[i].x < -300) groups.splice(i,1);
  }

  let hudGroup = waitTargetGroup;
  if(!hudGroup){
    let minX = Infinity;
    for(const g of groups){
      if(g.active && g.x < canvas.width + 100){
        if(g.x < minX){ minX = g.x; hudGroup = g; }
      }
    }
  }
  if(hudGroup){
    drawBigHeadstockLabel(ctx, hudGroup);
  }

  if(isSongMode){
    const done = (songFinished || songIndex >= SONG_DATA.length);
    if(done && groups.length===0){
      endGame();
      return;
    }
    if(done && songFinishedAt && (performance.now()-songFinishedAt)>8000){
      endGame();
      return;
    }
  }

  if(!waitHold){
    let cand = null;
    let candAX = Infinity;

    for(const g of groups){
      if(!g.active) continue;
      if(!g.entered) continue;
      if(g._autoMissed) continue;
      const ax = g.getAnchorX();
      if(ax < g.getAutoMissX()){
        if(ax < candAX){ cand = g; candAX = ax; }
      }
    }

    if(cand){
      cand._autoMissed = true;
      comboStreak = 0;
      resetSpeedState();
      updateComboUI();

      const missMsg = ['„Åä„Å°„Å§„ÅÑ„Å¶','„Å†„ÅÑ„Åò„Çá„ÅÜ„Å∂ÔºÅ','„ÇÇ„ÅÜ„ÅÑ„Å£„Åã„ÅÑÔºÅ','„ÇÜ„Å£„Åè„Çä„ÅßOK','„ÅÇ„Çè„Å¶„Å™„ÅÑÔºÅ'][Math.floor(Math.random()*5)];
      showFx(missMsg, 'miss', { durationMs: 2600 });

      try{ if(!IS_IOS && typeof showPandaHint==='function') showPandaHint(missMsg); }catch(e){}
      try{ const p=getFxPointFromGroup(target||waitTargetGroup); burstStars(14, p.x, p.y, 1); }catch(e){ burstStars(10, NUT_X+260, getNeckMidY(), 1); }
      if(isWaitMode()){
        waitHold = true;
        scrollSpeed = 0;
        waitTargetGroup = cand;
        cand.x = NUT_X;
        cand._autoMissed = false; 
      } else {
        cand.active = false;
      }
    }
  }

// „Ç®„Éï„Çß„ÇØ„Éà
  stars.forEach(s=>{ s.update(); s.draw(); });
  stars = stars.filter(s=>s.life>0);
  if(stars.length > STAR_CAP) stars.splice(0, stars.length-STAR_CAP);

  // „Éû„Ç§„ÇØÂà§ÂÆö
  processMicInput();

  }catch(e){
    console.error(e);
    if(!window.__lastRuntimeErrAt || (performance.now()-window.__lastRuntimeErrAt)>2000){
      window.__lastRuntimeErrAt = performance.now();
      try{ showFx('‚ö†Ô∏è „ÅÑ„Å£„Åü„ÇìÁ∂öË°å„Åó„Åæ„Åô', {kind:'miss'}); }catch(_){ }
    }
  }
  rafId = requestAnimationFrame(gameLoop);
}

function endGame(){
  if(gameState === 'RESULT') return;
  try{ document.body.classList.remove('playing'); }catch(e){}
  gameState='RESULT';
  cancelAnimationFrame(rafId);
  
  // FINISHÊºîÂá∫
  const finishEl = document.createElement('div');
  finishEl.style.cssText = `
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5);
    z-index: 9999; pointer-events: none; opacity: 0;
    font-size: 64px; font-weight: 900; color: #fff;
    text-shadow: 0 4px 0 #ff7a3d, 0 10px 20px rgba(0,0,0,0.4);
    transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.6s ease;
    white-space: nowrap;
  `;
  finishEl.innerText = "FINISH!!";
  document.getElementById('app').appendChild(finishEl);

  setTimeout(()=>{
    finishEl.style.transform = "translate(-50%, -50%) scale(1)";
    finishEl.style.opacity = "1";
    try{ 
        if(typeof playFreqs === 'function') {
            playFreqs([261.63, 329.63, 392.00, 523.25], 1.0); 
        }
    }catch(e){}
  }, 100);

  setTimeout(()=>{
    finishEl.style.opacity = "0";
    finishEl.style.transform = "translate(-50%, -50%) scale(1.5)";
    setTimeout(()=>finishEl.remove(), 600);

    document.getElementById('result-score').innerText = score;
    let msg = "Good Job!";
    if(score > 600) msg = "Amazing!! üèÜ";
    else if(score > 300) msg = "Great!! üåü";
    else if(score > 100) msg = "Nice! üëç";
    document.getElementById('result-msg').innerText = msg;
    document.getElementById('result-overlay').style.display='flex';
    
    setTimeout(()=>{
       try{ 
           if(typeof playFreqs === 'function') {
               playFreqs([261.63, 329.63, 392.00, 523.25, 659.25], 1.5); 
           }
       }catch(e){}
    }, 300);
  }, 2200);
}

// --- ÂÖ•ÂäõÂà§ÂÆö ---
function processMicInput(){
  if(entryKind==='tap' || !micAnalyser) return;
  const buf = new Float32Array(micAnalyser.fftSize);
  micAnalyser.getFloatTimeDomainData(buf);
  let rms=0; for(let i=0; i<buf.length; i++) rms+=buf[i]*buf[i];
  const val = Math.sqrt(rms/buf.length);

  const rise = val - prevRms;
  const now = Date.now();
  if(now >= ignorePluckUntil && val > PLUCK_HIGH_RMS && rise > PLUCK_RISE_RMS){
    pluckHoldCount++;
  } else {
    pluckHoldCount = Math.max(0, pluckHoldCount-1);
  }
  prevRms = val;

  if(pluckHoldCount>=2){
    pluckHoldCount=0; ignorePluckUntil=now+250;
    handleAction();
  }
}

function handleAction(){
  if(gameState!=='PLAY') return;
  let target=null, best=Infinity;
  if(waitHold && waitTargetGroup && waitTargetGroup.active){
    target = waitTargetGroup; best = Math.abs(target.x - NUT_X);
  } else {
    for(let g of groups){
      if(!g.active) continue;
      const d = Math.abs(g.x - NUT_X);
      if(d < 620 && d > -220){ if(d<best){ best=d; target=g; } }
    }
  }

  if(target){
    const win = 110;
    if(best < win){
      // HIT
      target.active=false;
      try{ playTapHitSound(target); }catch(e){}

      if(waitHold){
        waitHold=false; scrollSpeed=currentScrollSpeed; waitTargetGroup=null; lastSpawn=performance.now();
      }
      score += (best<50 ? 15 : 10);
      document.getElementById('score').innerText=score;
      try{ const p=getFxPointFromGroup(target||waitTargetGroup); burstStars(14, p.x, p.y, 1); }catch(e){ burstStars(10, NUT_X+260, getNeckMidY(), 1); }
      comboStreak++;
      updateComboUI();

      const cheer = CHEER_PHRASES[Math.floor(Math.random()*CHEER_PHRASES.length)];

      if(gameMode==='scale'){
        if(!scaleSpeedBoosted){
          if(target.noteKey === 'do'){
            scaleSeqCount = 1;
          } else if(scaleSeqCount > 0){
            scaleSeqCount++;
          } 

          if(scaleSeqCount >= 8){
            scaleSpeedBoosted = true;
            if(!disableSpeedUpActive){ currentScrollSpeed = baseScrollSpeed * SPEEDUP_MULT; }
            if(gameState==='PLAY' && !waitHold) scrollSpeed = currentScrollSpeed;

            showFx(`üí• 8Èü≥„Éé„Éº„Éü„ÇπÔºÅ\n„Çπ„Éî„Éº„ÉâUP!!`, 'speed', { mega:true, durationMs: 1200 });
            try{ const p=getFxPointFromGroup(target||waitTargetGroup); burstStars(14, p.x, p.y, 1); }catch(e){ burstStars(10, NUT_X+260, getNeckMidY(), 1); }
} else {
            try{const p=getFxPointFromGroup(target); showFx(`‚ú®PERFECT!!‚ú®\n${comboStreak}ÈÄ£Á∂ö  ${cheer}`, 'hit', { mega:false, durationMs: 1760 , x:p.x, y:p.y});}catch(e){ showFx(`‚ú®PERFECT!!‚ú®\n${comboStreak}ÈÄ£Á∂ö  ${cheer}`, 'hit', { mega:false, durationMs: 1760 });}
            try{ const p=getFxPointFromGroup(target||waitTargetGroup); burstStars(14, p.x, p.y, 1); }catch(e){ burstStars(10, NUT_X+260, getNeckMidY(), 1); }
}
        } else {
          try{const p=getFxPointFromGroup(target); showFx(`üî•NICE!!üî•\n${comboStreak}ÈÄ£Á∂ö  ${cheer}`, 'hit', { mega:false, durationMs: 1640 , x:p.x, y:p.y});}catch(e){ showFx(`üî•NICE!!üî•\n${comboStreak}ÈÄ£Á∂ö  ${cheer}`, 'hit', { mega:false, durationMs: 1640 });}
          try{ const p=getFxPointFromGroup(target||waitTargetGroup); burstStars(14, p.x, p.y, 1); }catch(e){ burstStars(10, NUT_X+260, getNeckMidY(), 1); }
}

      } else {
        const canSpeedUp = (gameMode === 'practice');
        const hitMilestone = (canSpeedUp && !disableSpeedUpActive && comboStreak > 0 && (comboStreak % 5 === 0));
        
        if(hitMilestone){
          practiceBoostCount++;
          currentScrollSpeed += SPEED_STEP; 

          if(gameState==='PLAY' && !waitHold) scrollSpeed = currentScrollSpeed;
          
          if(gameEndAt != null) {
            gameEndAt += 5000; 
            showTimeBonus("+5Áßí!");
          }
          
          triggerRainbowFlash();
          showFx(`üí• ${comboStreak} COMBO!! üí•\n„Çπ„Éî„Éº„ÉâUP!! (${currentScrollSpeed.toFixed(1)})`, 'speed', { mega:true, durationMs: 2000 });
          try{ const p=getFxPointFromGroup(target||waitTargetGroup); burstStars(20, p.x, p.y, 2); }catch(e){ burstStars(10, NUT_X+260, getNeckMidY(), 1); }

        } else {
          const label = (best<50) ? '‚ú®PERFECT!!‚ú®' : 'üî•NICE!!üî•';
          try{const p=getFxPointFromGroup(target); showFx(`${label}\n${comboStreak}ÈÄ£Á∂ö  ${cheer}`, 'hit', { mega:false, durationMs: 1800 , x:p.x, y:p.y});}catch(e){ showFx(`${label}\n${comboStreak}ÈÄ£Á∂ö  ${cheer}`, 'hit', { mega:false, durationMs: 1800 });}
          try{ const p=getFxPointFromGroup(target||waitTargetGroup); burstStars(14, p.x, p.y, 1); }catch(e){ burstStars(10, NUT_X+260, getNeckMidY(), 1); }
        }
      }
} else {
      comboStreak = 0;
      resetSpeedState();
      updateComboUI();

      const missMsg = ['„Åä„Å°„Å§„ÅÑ„Å¶','„Å†„ÅÑ„Åò„Çá„ÅÜ„Å∂ÔºÅ','„ÇÇ„ÅÜ„ÅÑ„Å£„Åã„ÅÑÔºÅ','„ÇÜ„Å£„Åè„Çä„ÅßOK','„ÅÇ„Çè„Å¶„Å™„ÅÑÔºÅ'][Math.floor(Math.random()*5)];
      showFx(missMsg, 'miss', { durationMs: 2600 });
      try{ if(typeof showPandaHint==='function') showPandaHint(missMsg); }catch(e){}
      try{ const p=getFxPointFromGroup(target||waitTargetGroup); burstStars(14, p.x, p.y, 1); }catch(e){ burstStars(10, NUT_X+260, getNeckMidY(), 1); }
if(isWaitMode()){
        if(!waitHold){
          waitHold=true; scrollSpeed=0; waitTargetGroup=target; target.x=NUT_X;
        }
      } else {
        target.active=false;
      }
    }
  }
}

// --- NEW LABEL DRAWER ---
function drawBigHeadstockLabel(ctx, group){
  if(!group || !group.chord) return;

  const nmRaw = group.chord.name || "";
  let nm = nmRaw;
  
  const isScale = (gameMode === 'scale');
  const isSong = !!isSongMode;
  if(isSong && !isScale){
    if(group.chord.fingers && group.chord.fingers.length === 1){
      try{ nm = noteNameForFinger(group.chord.fingers[0]); }catch(e){ nm = ''; }
    }
  }

  if(!nm) return;

  const cx = 36; 
  const cy = canvas.height / 2;
  
  const isWaiting = (waitHold && waitTargetGroup === group);
  const alpha = isWaiting ? (0.6 + 0.4*Math.sin(performance.now()/80)) : 1.0;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = "#fff";
  ctx.strokeStyle = "rgba(0,0,0,0.5)";
  ctx.lineWidth = 6;
  ctx.font = "900 34px system-ui, -apple-system, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const tw = ctx.measureText(nm).width;
  const bw = tw + 20; 
  const bh = 54;      
  
  ctx.save();
  ctx.globalAlpha = alpha * 0.6;
  ctx.fillStyle = "#4a3728"; 
  ctx.beginPath();
  const r = 10;
  const bx = cx - bw/2, by = cy - bh/2;
  ctx.moveTo(bx+r, by);
  ctx.arcTo(bx+bw, by, bx+bw, by+bh, r);
  ctx.arcTo(bx+bw, by+bh, bx, by+bh, r);
  ctx.arcTo(bx, by+bh, bx, by, r);
  ctx.arcTo(bx, by, bx+bw, by, r);
  ctx.fill();
  ctx.restore();

  ctx.strokeText(nm, cx, cy);
  ctx.fillText(nm, cx, cy);

  ctx.restore();
}


// --- ÊèèÁîª„ÇØ„É©„Çπ ---
class ChordGroup {
  constructor(chord, lyrics){
    this.chord=chord; this.lyrics=lyrics;
    this.x = canvas.width+120; this.active=true; this.ticked=false; this.isTarget=false;
    this.born = performance.now();
    this.entered = false;
  }
  update(){
    this.x -= scrollSpeed;
    if(!this.entered && this.x < (canvas.width + 60)) this.entered = true; 
    if(!this.ticked && this.x<=NUT_X){ this.ticked=true; }
  }
  getAnchorX(){
    const fw = (canvas.width - NUT_X - STAGE.FRET_RIGHT_PAD) / STAGE.FRET_COUNT;
    const fretsAll = this.chord.fingers.map(f=>f.f);
    const maxF = Math.max(...fretsAll);
    const minF = Math.min(...fretsAll);
    const hasOpen = (minF === 0);
    const hasPressed = (maxF > 0);
    const minPressed = hasPressed ? Math.min(...fretsAll.filter(f=>f>0)) : 0;
    const shiftOpenToLeftMostPressed = (hasOpen && hasPressed);

    const fretCenterX = (baseX, fret)=>{
      if(fret > 0) return baseX + (fret*fw) - (fw/2);
      if(shiftOpenToLeftMostPressed && fret === 0){
        return baseX + (minPressed*fw) - (fw/2);
      }
      return baseX;
    };

    let minX = Infinity;
    for(const fg of this.chord.fingers){
      const x = fretCenterX(this.x, fg.f);
      if(x < minX) minX = x;
    }
    return minX;
  }

  getAutoMissX(){
    const fw = (canvas.width - NUT_X - STAGE.FRET_RIGHT_PAD) / STAGE.FRET_COUNT;

    const fretsAll = this.chord.fingers.map(f=>f.f);
    const maxF = Math.max(...fretsAll);
    const minF = Math.min(...fretsAll);
    const hasOpen = (minF === 0);
    const hasPressed = (maxF > 0);
    const minPressed = hasPressed ? Math.min(...fretsAll.filter(f=>f>0)) : 0;
    const shiftOpenToLeftMostPressed = (hasOpen && hasPressed);

    let dispMinF = Infinity;
    for(const f of fretsAll){
      const df = (shiftOpenToLeftMostPressed && f===0) ? minPressed : f;
      if(df < dispMinF) dispMinF = df;
    }
    if(!isFinite(dispMinF)) dispMinF = 0;

    const intendedLeftmostX = (dispMinF > 0) ? (NUT_X + (dispMinF*fw) - (fw/2)) : NUT_X;

    return intendedLeftmostX - fw;
  }

  draw(){
    if(!this.active) return;
    const cy = canvas.height/2;
    const fw = (canvas.width - NUT_X - STAGE.FRET_RIGHT_PAD) / STAGE.FRET_COUNT;

    const fretsAll = this.chord.fingers.map(f=>f.f);
    const maxF = Math.max(...fretsAll);
    const minF = Math.min(...fretsAll);
    const hasOpen = (minF === 0);
    const hasPressed = (maxF > 0);
    const minPressed = hasPressed ? Math.min(...fretsAll.filter(f=>f>0)) : 0;
    const shiftOpenToLeftMostPressed = (hasOpen && hasPressed);

    const fretCenterX = (baseX, fret)=>{
      if(fret > 0) return baseX + (fret*fw) - (fw/2);
      if(shiftOpenToLeftMostPressed && fret === 0){
        return baseX + (minPressed*fw) - (fw/2);
      }
      return baseX; // ÈñãÊîæ„ÅÆ„Åø„ÅÆÂ†¥Âêà„ÅØ„Éä„ÉÉ„Éà
    };
const fretToX = (fret)=> fretCenterX(this.x, fret);
    if(this.isTarget && Math.abs(this.x-NUT_X)<620){
      const t = Math.max(0, 1 - Math.abs(this.x-NUT_X)/620);
      this.chord.fingers.forEach(f=>{
        const fx = fretCenterX(NUT_X, f.f);
        const fy = cy + (f.s-2.5)*75;
        drawCircle(fx, fy, f.txt, 32+t*10, 0.2+t*0.6, true);
      });
      this.isTarget=false;
    }
    const blink = (waitHold && waitTargetGroup===this) ? (0.5+0.5*Math.sin(performance.now()/100)) : 1.0;
    this.chord.fingers.forEach(f=>{
      const fx = fretToX(f.f);
      const fy = cy + (f.s-2.5)*75;
      drawCircle(fx, fy, f.txt, 40, 1.0, false, blink);
    });
  }
}
function drawCircle(x,y,txt,size,alpha,blur,scale=1){
  ctx.save(); ctx.globalAlpha=alpha;
  if(blur) ctx.filter="blur(2px)";
  ctx.translate(x,y); ctx.scale(scale,scale);
  ctx.beginPath(); ctx.arc(0,0,size,0,Math.PI*2);
  ctx.fillStyle = (txt==='Ëñ¨')?'#5271ff':(txt==='‰∏≠'?'#ff66c4':(txt==='‰∫∫'?'#ff914d':'#888'));
  ctx.fill(); ctx.strokeStyle="#fff"; ctx.lineWidth=4; ctx.stroke();
  ctx.filter="none"; ctx.fillStyle="#fff"; ctx.font=`bold ${size*0.75}px sans-serif`;
  ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(txt,0,2);
  ctx.restore();
}
class Star {
  constructor(x,y){ this.x=x;this.y=y;this.vx=(Math.random()-.5)*20;this.vy=(Math.random()-.5)*20;this.life=1; }
  update(){ this.x+=this.vx;this.y+=this.vy;this.vy+=0.5;this.life-=0.03; }
  draw(){ ctx.save();ctx.globalAlpha=this.life;ctx.fillStyle="#ffeb3b";ctx.beginPath();ctx.arc(this.x,this.y,6,0,Math.PI*2);ctx.fill();ctx.restore(); }
}

function drawFretboard(){
  drawFretboardBase(ctx, canvas, STRING_COLORS);
}


function applyViewportSize(){
  const vv = window.visualViewport;
  const w = vv ? vv.width  : (document.documentElement.clientWidth  || window.innerWidth);
  const h = vv ? vv.height : (document.documentElement.clientHeight || window.innerHeight);
  document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
  canvas.width  = Math.floor(w);
  canvas.height = Math.floor(h);
}
applyViewportSize();
if (window.visualViewport){
  window.visualViewport.addEventListener('resize', applyViewportSize);
}
window.addEventListener('resize', applyViewportSize);
window.addEventListener('orientationchange', () => setTimeout(applyViewportSize, 250));
// „Çø„ÉÉ„ÉóÊìç‰Ωú
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); if(entryKind==='tap') handleAction(); }, {passive:false});
canvas.addEventListener('mousedown', ()=>{ if(entryKind==='tap') handleAction(); });

// UIBAR FIX PATCH (disabled on iOS)
(function(){
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
  if (isIOS) return;
function nudge(){ try{ window.scrollTo(0, 1); }catch(e){} setTimeout(function(){ try{ window.scrollTo(0, 1); }catch(e){} }, 50); }
  window.addEventListener('touchstart', nudge, {passive:true});
  window.addEventListener('touchend',   nudge, {passive:true});
  window.addEventListener('click',      nudge, {passive:true});
  window.addEventListener('orientationchange', function(){ setTimeout(nudge, 250); }, {passive:true});
  window.addEventListener('pageshow', function(){ setTimeout(nudge, 250); }, {passive:true});
  setTimeout(nudge, 300);

})();

// __setMenuClassInit
try{ document.body.classList.add('isMenu'); }catch(e){}
/* === PAGE_FLIP_TRANSITION v1 (shared) === */
let __navLock = false;
function goFlip(url){
  if(__navLock) return;
  __navLock = true;
  try{ window.stopTapPreview && window.stopTapPreview(); }catch(e){}
  const ov = document.getElementById('pageFlip');
  if(!ov){ location.href = url; return; }
  ov.style.display = 'block';
  ov.classList.remove('run');
  void ov.offsetWidth;
  ov.classList.add('run');
  setTimeout(()=>{ location.href = url; }, 260);
}
window.addEventListener('pageshow', ()=>{
  __navLock = false;
  const ov = document.getElementById('pageFlip');
  if(ov){ ov.classList.remove('run'); ov.style.display='none'; }
});


// v23: mode flag for menu UI (mode=TAP => tap, else uke)
(function(){
  try{
    const p = new URLSearchParams(location.search);
    const isTap = (p.get('mode')||'').toUpperCase()==='TAP';
    document.body.classList.toggle('is-tap', isTap);
    document.body.classList.toggle('is-uke', !isTap);
  }catch(e){
    document.body.classList.add('is-uke');
  }
})();


// ===== v79: WebAudio FIX & Sound Design =====
(function(){
  // --- helpers ---
  function clamp01(x){
    x = Number(x);
    if(!Number.isFinite(x)) return 0.35;
    return Math.max(0, Math.min(1, x));
  }

  function getTapVolume01(){
    const s = document.getElementById('tapVolume'); // visible slider (0..1)
    if(s){
      const v = Number(s.value);
      return clamp01(Number.isFinite(v)? v : 0.35);
    }
    const s100 = document.getElementById('tapVol'); // legacy hidden (0..100)
    if(s100){
      const v = Number(s100.value);
      const min = Number(s100.getAttribute('min') || 0);
      const max = Number(s100.getAttribute('max') || 100);
      const vol01 = (v - min) / (max - min || 1);
      return clamp01(vol01);
    }
    return clamp01(typeof tapVol !== 'undefined' ? tapVol : 0.35);
  }

  function setTapVolume01(v01){
    v01 = clamp01(v01);
    try{ tapVol = v01; }catch(e){}
    const s = document.getElementById('tapVolume');
    if(s) s.value = String(v01);

    // keep legacy hidden input in sync (0..100)
    const s100 = document.getElementById('tapVol');
    if(s100){
      const min = Number(s100.getAttribute('min') || 0);
      const max = Number(s100.getAttribute('max') || 100);
      const v = Math.round(min + v01 * (max - min));
      s100.value = String(v);
    }
    try{ saveTapVol(); }catch(e){}
  }

  window.applyTapVolumeToGain = function(){
    try{
      const v = getTapVolume01();
      const g = Math.pow(v, 2.2); 
      if(typeof tapMaster !== 'undefined' && tapMaster && typeof tapAudioCtx !== 'undefined' && tapAudioCtx){
        tapMaster.gain.setTargetAtTime(g, tapAudioCtx.currentTime, 0.015);
      }
    }catch(e){}
  };

  // --- Legacy Preview Cleaner ---
  window.stopTapPreview = function(){ 
    // No-op
  };

  // --- Hit Sound (WebAudio) - UKULELE TONE FIX ---
  const origPlay = (typeof playTapHitSound === 'function') ? playTapHitSound : null;
  const NOTE = {do:261.63, re:293.66, mi:329.63, fa:349.23, so:392.00, la:440.00, si:493.88, do2:523.25};
  const JP = {'„Éâ':'do','„É¨':'re','„Éü':'mi','„Éï„Ç°':'fa','„ÇΩ':'so','„É©':'la','„Ç∑':'si'};
  const STR_BASE = {A:440.00, E:329.63, C:261.63, G:392.00, '„É©':440.00, '„Éü':329.63, '„Éâ':261.63, '„ÇΩ':392.00};

  function noteNameToFreq(name){
    try{
      name = String(name||'').trim();
      const m = name.match(/^([A-Ga-g])([#b]?)(-?\d+)$/);
      if(!m) return null;
      const n = m[1].toUpperCase(), acc = m[2], oct = parseInt(m[3],10);
      const base = {C:0,D:2,E:4,F:5,G:7,A:9,B:11}[n];
      let semis = base + (acc==='#'?1:0) + (acc==='b'?-1:0);
      const midi = (oct + 1) * 12 + semis;
      return 440 * Math.pow(2,(midi-69)/12);
    }catch(e){ return null; }
  }

  // --- SUSTAIN MANAGEMENT (v80) ---
  const activeVoices = []; // {osc, gain, startTime}

  function stopAllVoices(){
    if(!tapAudioCtx) return;
    const now = tapAudioCtx.currentTime;
    activeVoices.forEach(v => {
      try {
        if(v.gain.gain){
          v.gain.gain.cancelScheduledValues(now);
          v.gain.gain.setValueAtTime(v.gain.gain.value, now); 
          v.gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4); 
          v.gain.gain.linearRampToValueAtTime(0, now + 0.5);
        }
        if(Array.isArray(v.osc)) v.osc.forEach(o => o.stop(now + 0.6));
        else v.osc.stop(now + 0.6);
      } catch(e){}
    });
    activeVoices.length = 0;
  }

  // NOTE: ‰ΩôÈüª„ÇíÊÆã„Åô„Åü„ÇÅ„ÄÅpointerup „ÅßÂº∑Âà∂ÂÅúÊ≠¢„Åó„Å™„ÅÑÔºàÊ¨°„ÅÆÁô∫Èü≥ÊôÇ„Å´Ëá™ÁÑ∂„Å´„Éï„Çß„Éº„Éâ„Åó„Åæ„ÅôÔºâ

  function getUkeNoiseBuffer() {
      if (window.__ukeNoiseBuf) return window.__ukeNoiseBuf;
      if (!tapAudioCtx) return null;
      const bufSize = tapAudioCtx.sampleRate * 0.05; 
      const buf = tapAudioCtx.createBuffer(1, bufSize, tapAudioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for(let j=0; j<bufSize; j++) {
          data[j] = (Math.random() * 2 - 1) * Math.exp(-j / (tapAudioCtx.sampleRate * 0.005));
      }
      window.__ukeNoiseBuf = buf;
      return buf;
  }

  // --- Áô∫Èü≥„Éê„ÇπÔºà‰ΩôÈüª/ÁÆ±È≥¥„Çä„ÇíÂ∞ë„ÅóË∂≥„ÅôÔºö„Éù„ÉÉ„ÉóÈü≥„ÅØÈÄö„Åï„Å™„ÅÑÔºâ ---
  let hitIn = null, hitOut = null, hitDry = null, hitWet = null, hitConv = null, hitDelay = null, hitFb = null;

  function buildSmallRoomIR(ctx, seconds=0.9){
    const rate = ctx.sampleRate;
    const len = Math.max(1, Math.floor(rate * seconds));
    const ir = ctx.createBuffer(2, len, rate);
    for(let ch=0; ch<2; ch++){
      const data = ir.getChannelData(ch);
      for(let i=0; i<len; i++){
        const t = i / len;
        const env = Math.pow(1 - t, 2.2) * Math.exp(-t * 4.0);
        data[i] = (Math.random() * 2 - 1) * env * 0.32;
      }
    }
    return ir;
  }

  function ensureHitBus(){
    ensureTapAudio();
    if(hitIn) return;
    hitIn  = tapAudioCtx.createGain();
    hitOut = tapAudioCtx.createGain();
    hitDry = tapAudioCtx.createGain();
    hitWet = tapAudioCtx.createGain();

    hitDry.gain.value = 1.0;
    hitWet.gain.value = 0.14;   // „Åª„Çì„ÅÆ„Çä
    hitOut.gain.value = 1.0;

    hitConv = tapAudioCtx.createConvolver();
    hitConv.buffer = buildSmallRoomIR(tapAudioCtx, 0.9);

    hitDelay = tapAudioCtx.createDelay(0.08);
    hitDelay.delayTime.value = 0.024; // 24ms
    hitFb = tapAudioCtx.createGain();
    hitFb.gain.value = 0.22;

    // wiring
    hitIn.connect(hitDry).connect(hitOut);
    hitIn.connect(hitDelay);
    hitDelay.connect(hitFb); hitFb.connect(hitDelay); // feedback
    hitDelay.connect(hitConv);
    hitConv.connect(hitWet).connect(hitOut);

    // master„Å∏ÔºàÈü≥Èáè„Çπ„É©„Ç§„ÉÄ„Éº„Å®„Ç≥„É≥„Éó„É¨„ÉÉ„Çµ„ÅØ tapMaster ÂÅ¥„Å´„ÅÇ„ÇãÔºâ
    hitOut.connect(tapMaster);
  }

  // ‚òÖÈü≥ÂÜçÁîü„Ç®„É≥„Ç∏„É≥: „Çµ„É≥„Éó„É™„É≥„Ç∞ÂØæÂøúÁâà
  window.playFreqs = function(freqs, dur){
    try{
      ensureTapAudio();
      ensureHitBus();
      stopAllVoices(); 
      
      const now = tapAudioCtx.currentTime;
      
      // „Çµ„É≥„Éó„É™„É≥„Ç∞„É¢„Éº„Éâ„Å™„ÇâÈå≤Èü≥„Éê„ÉÉ„Éï„Ç°„Çí‰Ωø„ÅÜ
      if(useSampledSound && window.hasRecordedSamples){
        freqs.forEach((item, i) => {
          let f = 440, sIdx = 0;
          if(typeof item === 'number') { f = item; sIdx = 0; }
          else { f = item.freq; sIdx = item.stringIdx; }

          if(!window.customSamples[sIdx]) return; // „Éá„Éº„Çø„Å™„Åë„Çå„Å∞„Çπ„Ç≠„ÉÉ„Éó

          const strumDelay = i * 0.03; 
          const startTime = now + strumDelay;
          
          const src = tapAudioCtx.createBufferSource();
          src.buffer = window.customSamples[sIdx];
          
          // „Éî„ÉÉ„ÉÅ„Ç∑„Éï„ÉàË®àÁÆó: playbackRate = target / base
          const bases = [440.00, 329.63, 261.63, 392.00];
          src.playbackRate.value = f / bases[sIdx];

          const gain = tapAudioCtx.createGain();
          // „ÇØ„É™„ÉÉ„ÉóÂõûÈÅøÔºöÂº¶Êï∞„Å´Âøú„Åò„Å¶Ëá™Âãï„Åß‰∏ã„Åí„ÇãÔºàÈå≤Èü≥Á¥†Êùê„ÅØ„Éî„Éº„ÇØ„ÅåÈ´ò„Åè„Å™„Çä„Åå„Å°Ôºâ
          const __N = Math.max(1, freqs.length);
          const __per = 0.34 / Math.sqrt(__N);

          // „É™„É™„Éº„ÇπÂà∂Âæ°: „Éï„Çß„Éº„Éâ„Ç¢„Ç¶„ÉàÔºà‰ΩôÈüª„ÇíÊÆã„ÅôÔºâ
          const bufferDur = src.buffer.duration / src.playbackRate.value;
          const playDur = Math.min(2.9, bufferDur);
          const rel = Math.min(0.75, Math.max(0.35, playDur * 0.28));

          gain.gain.setValueAtTime(__per, startTime);
          gain.gain.setValueAtTime(__per, Math.max(startTime, startTime + playDur - rel));
          gain.gain.linearRampToValueAtTime(0, startTime + playDur);

          src.connect(gain);
          gain.connect(hitIn);
src.start(startTime);
          activeVoices.push({ osc: [src], gain: gain, startTime: startTime });
        });
        return;
      }

      // --- ‰ª•‰∏ã„ÄÅÊó¢Â≠ò„ÅÆ„Ç∑„É≥„Çª„Çµ„Ç§„Ç∂„Éº„É≠„Ç∏„ÉÉ„ÇØ ---
      const N = Math.max(1, freqs.length);
      const baseGain = 0.4 / Math.sqrt(N); 
      
      const bodyFilter = tapAudioCtx.createBiquadFilter();
      bodyFilter.type = 'peaking';
      bodyFilter.frequency.value = 400; 
      bodyFilter.Q.value = 1.0;
      bodyFilter.gain.value = 3.0; 

      freqs.forEach((item, i) => {
        let f0 = (typeof item === 'number') ? item : item.freq;
        const f = Math.max(80, Math.min(2000, Number(f0) || 440));
        
        const strumDelay = i * 0.025 + (Math.random() * 0.005); 
        const startTime = now + strumDelay;

        const noiseBuf = getUkeNoiseBuffer();
        if(noiseBuf){
            const noiseSrc = tapAudioCtx.createBufferSource();
            noiseSrc.buffer = noiseBuf;
            const noiseFilter = tapAudioCtx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 3000; 
            const noiseGain = tapAudioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.1 * baseGain, startTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.02);
            noiseGain.gain.linearRampToValueAtTime(0, startTime + 0.03); 
            noiseSrc.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(hitIn);
            noiseSrc.start(startTime);
            noiseSrc.stop(startTime + 0.1); 
        }

        const osc1 = tapAudioCtx.createOscillator(); 
        const osc2 = tapAudioCtx.createOscillator(); 
        const osc3 = tapAudioCtx.createOscillator(); 

        osc1.type = 'sine';
        osc2.type = 'sine'; 
        osc3.type = 'sawtooth';

        const bend = f * 0.005;
        osc1.frequency.setValueAtTime(f + bend, startTime);
        osc1.frequency.exponentialRampToValueAtTime(f, startTime + 0.1);
        osc2.frequency.setValueAtTime((f * 2) + bend, startTime);
        osc2.frequency.exponentialRampToValueAtTime(f * 2, startTime + 0.1);
        osc3.frequency.setValueAtTime(f, startTime); 

        const mix1 = tapAudioCtx.createGain();
        const mix2 = tapAudioCtx.createGain();
        const mix3 = tapAudioCtx.createGain();

        mix1.gain.setValueAtTime(0.001, startTime);
        mix1.gain.linearRampToValueAtTime(1.0, startTime + 0.01);
        mix1.gain.exponentialRampToValueAtTime(0.15, startTime + 0.8); 
        mix1.gain.exponentialRampToValueAtTime(0.001, startTime + 2.0); 
        mix1.gain.linearRampToValueAtTime(0, startTime + 2.1); 

        mix2.gain.setValueAtTime(0.001, startTime);
        mix2.gain.linearRampToValueAtTime(0.3, startTime + 0.01);
        mix2.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4); 
        mix2.gain.linearRampToValueAtTime(0, startTime + 0.5); 

        mix3.gain.setValueAtTime(0.001, startTime);
        mix3.gain.linearRampToValueAtTime(0.08, startTime + 0.005);
        mix3.gain.exponentialRampToValueAtTime(0.001, startTime + 0.2); 
        mix3.gain.linearRampToValueAtTime(0, startTime + 0.25); 

        osc1.connect(mix1);
        osc2.connect(mix2);
        osc3.connect(mix3);

        const stringMix = tapAudioCtx.createGain();
        mix1.connect(stringMix);
        mix2.connect(stringMix);
        mix3.connect(stringMix);

        const lpFilter = tapAudioCtx.createBiquadFilter();
        lpFilter.type = 'lowpass';
        lpFilter.frequency.setValueAtTime(2200, startTime); 

        stringMix.connect(bodyFilter);
        bodyFilter.connect(lpFilter);
        
        const voiceGain = tapAudioCtx.createGain();
        voiceGain.gain.setValueAtTime(baseGain, startTime);
        voiceGain.gain.setValueAtTime(baseGain, startTime + 1.8);
        voiceGain.gain.exponentialRampToValueAtTime(0.001, startTime + 2.2);
        voiceGain.gain.linearRampToValueAtTime(0, startTime + 2.3);
        
        lpFilter.connect(voiceGain);
        voiceGain.connect(hitIn);

        osc1.start(startTime);
        osc2.start(startTime);
        osc3.start(startTime);
        
        const stopTime = startTime + 2.4; 
        osc1.stop(stopTime);
        osc2.stop(stopTime);
        osc3.stop(stopTime);
        
        activeVoices.push({
            osc: [osc1, osc2, osc3],
            gain: voiceGain,
            startTime: startTime
        });
      });
    }catch(e){ console.error(e); }
  };

  const UKE_FULL_CHORDS = {
    'C':  [3,0,0,0], 
    'F':  [0,1,0,2], 
    'G7': [2,1,2,0], 
    'Am': [0,0,0,2], 
    'G':  [2,3,2,0], 
    'A7': [0,0,1,0], 
    'Dm': [0,1,2,2], 
    'Em': [2,3,4,0], 
    'D7': [0,2,2,2]  
  };

  function getFreqsFromTarget(target){
    try{
      const name = target && target.chord && target.chord.name != null ? String(target.chord.name).trim() : '';
      if(name && UKE_FULL_CHORDS[name]){
        const shapes = UKE_FULL_CHORDS[name];
        const bases = [440.00, 329.63, 261.63, 392.00]; 
        
        const strOrder = [
           {base: bases[3], fret: shapes[3], sIdx: 3}, // G
           {base: bases[2], fret: shapes[2], sIdx: 2}, // C
           {base: bases[1], fret: shapes[1], sIdx: 1}, // E
           {base: bases[0], fret: shapes[0], sIdx: 0}  // A
        ];
        
        const freqs = [];
        strOrder.forEach(p => {
           freqs.push({
             freq: p.base * Math.pow(2, p.fret/12),
             stringIdx: p.sIdx
           });
        });
        return freqs;
      }
    }catch(e){}

    try{
      const nk = target && target.noteKey ? String(target.noteKey).toLowerCase().trim() : '';
      if(nk){
        if(NOTE[nk]) return [NOTE[nk]]; // Fallback for scale (no string info usually)
      }
    }catch(e){}

    try{
      const fingers = target && target.chord && Array.isArray(target.chord.fingers) ? target.chord.fingers : null;
      if(fingers && fingers.length){
        const freqs = [];
        for(const f of fingers){
          const sRaw = (f && (f.string ?? f.str ?? f.s)) != null ? String(f.string ?? f.str ?? f.s) : '';
          const fretRaw = (f && (f.fret ?? f.f)) != null ? f.fret ?? f.f : 0;
          const fret = Number(fretRaw);
          // Map s=1(A)..4(G) to internal 0..3
          const sIdxMap = {1:0, 2:1, 3:2, 4:3}; 
          const sIdx = sIdxMap[sRaw];
          const bases = {1:440.00, 2:329.63, 3:261.63, 4:392.00};
          const numBase = bases[sRaw];

          if(numBase != null && Number.isFinite(fret)){
            freqs.push({
              freq: numBase * Math.pow(2, fret/12),
              stringIdx: sIdx
            });
          }
        }
        if(freqs.length) return freqs;
      }
    }catch(e){}

    try{
      const nn = target && (target.note || target.noteName || target.pitchName) ? (target.note || target.noteName || target.pitchName) : '';
      const f = noteNameToFreq(nn);
      if(f) return [f];
    }catch(e){}

    return null;
  }

  window.playTapHitSound = function(target){
    try{ 
        if(typeof isTapMode === 'function' && !isTapMode()) {
            if(typeof isWaitMode === 'function' && isWaitMode()){
            } else {
                return; 
            }
        }
    }catch(e){}
    
    try{ setTapVolume01(getTapVolume01()); }catch(e){}
    try{ window.applyTapVolumeToGain(); }catch(e){}
    try{ ensureTapAudio(); }catch(e){}

    const freqs = getFreqsFromTarget(target);
    if(freqs && freqs.length){
      playFreqs(freqs, freqs.length >= 3 ? 0.22 : 0.18);
      return;
    }
    playFreqs([392.00, 261.63, 329.63, 523.25], 0.2);
  };

  function hookSlider(){
    const s = document.getElementById('tapVolume');
    if(!s) return;

    try{ loadTapVol(); }catch(e){}
    const v01 = getTapVolume01();
    setTapVolume01(v01);
    try{ window.applyTapVolumeToGain(); }catch(e){}

    // „Çπ„É©„Ç§„ÉÄ„ÉºÊìç‰Ωú„ÅÆ„Äå„Éù„ÉÉ„ÉóÈü≥„Äç„ÅØ„ÄÅiPhone Safari „ÅÆÂà∂Èôê„Åß
    // Êì¨‰ººÁöÑ„Å´ dispatch „Åï„Çå„Åü input „Å†„Å®È≥¥„Çâ„Å™„ÅÑ„Åì„Å®„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅ
    // ÂÆüÈöõ„ÅÆ„Éâ„É©„ÉÉ„Ç∞Êìç‰ΩúÔºàpointer/touchÔºâÂÅ¥„ÅßÈ≥¥„Çâ„Åó„Åæ„Åô„ÄÇ
    let __lastPop = 0;
    const __pop = ()=>{
      const t = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      if(t - __lastPop < 55) return;
      __lastPop = t;
      try{ playSliderFeedback(); }catch(_e){}
    };

    try{ if(typeof enhanceRangeSlider === 'function') enhanceRangeSlider(s, __pop); }catch(e){}

    const wake = ()=>{
      try{ ensureTapAudio(); }catch(e){}
      try{
        if(typeof tapAudioCtx !== 'undefined' && tapAudioCtx && tapAudioCtx.state === 'suspended'){
          tapAudioCtx.resume().catch(()=>{});
        }
      }catch(e){}
    };
    s.addEventListener('pointerdown', (e)=>{ wake(); try{ e.preventDefault(); }catch(_){ } }, {passive:false});
    s.addEventListener('touchstart',  (e)=>{ wake(); try{ e.preventDefault(); }catch(_){ } }, {passive:false});
    s.addEventListener('mousedown',   wake);

    const apply = (e)=>{
      try{ setTapVolume01(getTapVolume01()); }catch(e){}
      try{ window.applyTapVolumeToGain(); }catch(e){}
      wake();
).catch(()=>{});
          }else{
            playSliderFeedback();
          }
        }catch(err){}
      }
    };

    s.addEventListener('input', apply, {passive:true});
    s.addEventListener('change', apply, {passive:true});
  }

  function unlockAudioGlobal(){
    try{
      if(tapAudioCtx && tapAudioCtx.state === 'suspended') tapAudioCtx.resume();
      if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    }catch(e){}
    document.removeEventListener('touchstart', unlockAudioGlobal);
    document.removeEventListener('click', unlockAudioGlobal);
  }
  document.addEventListener('touchstart', unlockAudioGlobal, {once:true, passive:true});
  document.addEventListener('click', unlockAudioGlobal, {once:true, passive:true});


  window.addEventListener('DOMContentLoaded', ()=>{
    hookSlider();
    try{ bindSongSpeedUI(); }catch(e){}
  });
})();
</script>
<div aria-hidden="true" id="pageFlip"></div>
<div aria-live="polite" id="pandaHint" style="
  position:fixed;
  left:50%;
  transform:translateX(-50%);
  bottom:calc(env(safe-area-inset-bottom) + 10px);
  max-width:92vw;
  padding:8px 12px;
  border-radius:16px;
  background:rgba(255,255,255,0.88);
  color:#111;
  font-size:15px;
  font-weight:800;
  line-height:1.2;
  box-shadow:0 6px 16px rgba(0,0,0,0.12);
  opacity:0;
  transition:opacity .18s ease;
  pointer-events:none;
  z-index:9999;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
"></div>

<div id="landscapeLock" aria-hidden="true">
  <div class="landscapeCard" role="dialog" aria-label="Ê®™ÁîªÈù¢„Å´„Åó„Å¶„Å≠">
    <div class="landscapeRow">
      <div class="rabbit">üê∞</div>
      <div class="phone">üì±‚ÜîÔ∏è</div>
    </div>
    <div class="landscapeTitle">„Çà„Åì„Åå„ÇÅ„Çì„Å´ „Åó„Å¶„Å≠ÔºÅ</div>
    <p class="landscapeText">„Åì„ÅÆ„Ç¢„Éó„É™„ÅØ „Çà„Åì„Åå„ÇÅ„Çì„Åß „ÅÇ„Åù„Å∂„Çà</p>
    <div class="landscapeHint">ÔºàiPhone„ÅØÁîªÈù¢ÂõûËª¢„É≠„ÉÉ„ÇØ„ÇíOFF„Å´„Åó„Å¶„Å≠Ôºâ</div>
  </div>
</div>


<script>
(function(){
  function apply(){
    var portrait = window.innerHeight > window.innerWidth;
    document.body.classList.toggle('needLandscape', portrait);
    var lock = document.getElementById('landscapeLock');
    if(lock){
      lock.setAttribute('aria-hidden', portrait ? 'false' : 'true');
    }
  }
  window.addEventListener('resize', apply);
  window.addEventListener('orientationchange', function(){ setTimeout(apply, 60); });
  document.addEventListener('visibilitychange', function(){ setTimeout(apply, 60); });
  // try to lock orientation when supported (PWA/Android)
  try{
    if(screen.orientation && screen.orientation.lock){
      screen.orientation.lock('landscape').catch(function(){});
    }
  }catch(e){}
  apply();
})();

</script>
</body>
</html>